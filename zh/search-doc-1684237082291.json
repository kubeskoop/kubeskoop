[{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/zh/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/zh/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. 提示 Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":""},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/zh/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"/zh/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":""},{"title":"代码概览","type":0,"sectionRef":"#","url":"/zh/docs/contribute/code-overview","content":"","keywords":""},{"title":"整体概览​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#整体概览","content":""},{"title":"bpf​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#bpf","content":"Exporter所使用的eBPF程序源码。 "},{"title":"cmd​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#cmd","content":"CLI程序。 "},{"title":"deploy​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#deploy","content":"用于部署KubeSkoop的Helm chart和资源文件。 "},{"title":"docs​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#docs","content":"文档。 "},{"title":"pkg​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkg","content":"go包代码。 "},{"title":"rpc​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#rpc","content":"Exporter所使用的gRPC定义。 "},{"title":"test​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#test","content":"E2E测试。 "},{"title":"KubeSkoop diagnosis​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#kubeskoop-diagnosis","content":""},{"title":"cmd/skoop​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#cmdskoop","content":"skoop命令实现. "},{"title":"cmd/collector​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#cmdcollector","content":"collector命令实现. "},{"title":"pkg/skoop/cmd​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopcmd","content":"skoop命令的主要程序逻辑。 "},{"title":"pkg/skoop/assertions​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopassertions","content":"断言的类型定义，以及常用的断言实现，包括kubernetes和netstack。 "},{"title":"pkg/skoop/collector​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopcollector","content":"collector命令和CollectorManager 的定义与实现。 "},{"title":"pkg/skoop/context​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopcontext","content":"程序的运行时上下文，提供了诊断所需的集群或诊断任务的信息。同时，它也提供了命令行参数的解析，并允许其它模块将自己所需要的参数注册过来。 "},{"title":"pkg/skoop/infra​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopinfra","content":"云厂商相关代码的实现。 "},{"title":"pkg/skoop/k8s​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopk8s","content":"与Kubernetes集群相关的定义，以及实用工具。 "},{"title":"pkg/skoop/model​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopmodel","content":"与诊断相关的模型定义，包括Packet、Link、Action等。 "},{"title":"pkg/skoop/netstack​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopnetstack","content":"与Linux网路栈相关的定义以及解析工具，如路由、IPVS，以及iptables模拟。 "},{"title":"pkg/skoop/network​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopnetwork","content":"Network 的实现。 "},{"title":"pkg/skoop/nodemanager​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopnodemanager","content":"NetNodeManager的实现。 "},{"title":"pkg/skoop/plugin​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopplugin","content":"Plugin的实现，包括flannel, calico等。 "},{"title":"pkg/skoop/provider​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopprovider","content":"Provider的实现，包括generic, aliyun等。 "},{"title":"pkg/skoop/service​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopservice","content":"ServiceProcessor的实现，包括kube-proxy。 "},{"title":"pkg/skoop/skoop​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopskoop","content":"Diagnostor的实现。 "},{"title":"pkg/skoop/ui​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskoopui","content":"格式化输出以及Web UI。 "},{"title":"pkg/skoop/utils​","type":1,"pageTitle":"代码概览","url":"/zh/docs/contribute/code-overview#pkgskooputils","content":"实用工具。 "},{"title":"添加新云提供商","type":0,"sectionRef":"#","url":"/zh/docs/contribute/diagnose/new-cloud-provider","content":"","keywords":""},{"title":"实现InfraShim​","type":1,"pageTitle":"添加新云提供商","url":"/zh/docs/contribute/diagnose/new-cloud-provider#实现infrashim","content":"InfraShim用于对底层基础设施网络进行配置检查。 type InfraShim interface { NodeToNode(src *v1.Node, oif string, dst *v1.Node, packet *model.Packet) ([]model.Suspicion, error) NodeToExternal(src *v1.Node, oif string, packet *model.Packet) ([]model.Suspicion, error) }  NodeToNode(): 在两个节点之间进行数据传输。接受Kubernetes *v1.Node 用于源和目的、出网络接口名称以及*model.Pakcet作为参数，返回[]model.Suspicion作为结果。 NodeToExternal() : 在节点和外部网络（如互联网）之间进行数据传输。接受Kubernetes *v1.Node用于源、出网络接口名称以及*model.Packet作为参数，返回[]model.Suspicions作为结果。 InfraShim需要检查数据包是否能够在底层网络中到达其目的地址。如一个内网但是在集群外的地址应当检查路由或安全组配置；一个公网地址应当检查NAT是否配置正确。 InfraShim实现应当放在pkg/skoop/network/&lt;提供商名称&gt;下。 "},{"title":"实现Network​","type":1,"pageTitle":"添加新云提供商","url":"/zh/docs/contribute/diagnose/new-cloud-provider#实现network","content":"Network也位于pkg/skoop/network/&lt;提供商名称&gt;下。它的实现也是云提供商以及插件特定的，所以你需要为你支持的插件实现自己的Network。 type Network interface { Diagnose(ctx *ctx.Context, src model.Endpoint, dst model.Endpoint) ([]model.Suspicion, *model.PacketPath, error) }  Diagnose(): 接受 *ctx.Context，*model.Endpoint类型的源和目的地址作为参数，返回[]model.Suspicion和*model.PacketPath作为结果。 Network应当对诊断过程中所需需要的所有资源进行配置，包括Plugin、Diagnostor、InfraShim等。 "},{"title":"添加新的Provider​","type":1,"pageTitle":"添加新云提供商","url":"/zh/docs/contribute/diagnose/new-cloud-provider#添加新的provider","content":"Provider位于pkg/skoop/provider。 type Provider interface { CreateNetwork(ctx *ctx.Context) (network.Network, error) }  CreateNetwork(): 接受 *ctx.Context作为参数，返回network.Network。 Provider的实现过程很简单：检查网络插件类型，并为其创建对应的Network。 type genericProvider struct { } func (g genericProvider) CreateNetwork(ctx *context.Context) (network.Network, error) { switch ctx.ClusterConfig().NetworkPlugin { case context.NetworkPluginFlannel: return generic.NewFlannelNetwork(ctx) case context.NetworkPluginCalico: return generic.NewCalicoNetwork(ctx) default: return nil, fmt.Errorf(&quot;not support cni type %q&quot;, ctx.ClusterConfig().NetworkPlugin) } }  你需要在pkg/skoop/provider/&lt;提供商名称&gt;.go中实现你的Provider。 之后，需要为新的提供商类型添加一个常量，位于pkg/skoop/provider/provider.go。 const ( providerNameGeneric = &quot;generic&quot; providerNameAliyun = &quot;aliyun&quot; // 在此处添加新的提供商名称 )  这个常量的值也会在命令行参数中被使用。 最后，把你的实现添加到providers中。 var providers = map[string]Provider{ providerNameGeneric: genericProvider{}, providerNameAliyun: aliyunProvider{}, // 添加新的提供商 }  "},{"title":"云提供商所使用的其它组件​","type":1,"pageTitle":"添加新云提供商","url":"/zh/docs/contribute/diagnose/new-cloud-provider#云提供商所使用的其它组件","content":"云提供商相关的组件放在pkg/skoop/infra/&lt;提供商名称&gt;下，比如配置或是云客户端。 如果你想为你的插件添加命令行参数，你应当实现ConfigBinder接口并将其注册到程序中。如pkg/skoop/infra/aliyun/config.go中的实现： type ProviderConfig struct { AccessKeyID string AccessKeySecret string SecurityToken string } var Config = &amp;ProviderConfig{} func init() { context.RegisterConfigBinder(&quot;Aliyun provider&quot;, Config) } func (pc *ProviderConfig) BindFlags(fs *pflag.FlagSet) { fs.StringVarP(&amp;pc.AccessKeyID, &quot;aliyun-access-key-id&quot;, &quot;&quot;, &quot;&quot;, &quot;Aliyun access key.&quot;) fs.StringVarP(&amp;pc.AccessKeySecret, &quot;aliyun-access-key-secret&quot;, &quot;&quot;, &quot;&quot;, &quot;Aliyun access secret.&quot;) fs.StringVarP(&amp;pc.SecurityToken, &quot;aliyun-security-token&quot;, &quot;&quot;, &quot;&quot;, &quot;Aliyun security token (optional).&quot;) } func (pc *ProviderConfig) Validate() error { return nil }  "},{"title":"架构","type":0,"sectionRef":"#","url":"/zh/docs/contribute/diagnose/architecture","content":"","keywords":""},{"title":"关键组件​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#关键组件","content":""},{"title":"Provider​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#provider","content":"云提供商的抽象，负责探测集群的网络类型，以及创建Network。 "},{"title":"Network​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#network","content":"云提供商特定的网络。Network中应当对诊断过程中需要的所有资源进行配置，包括Plugin、Diagnostor、InfraShim等。 "},{"title":"Diagnostor​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#diagnostor","content":"诊断算法的实现。该算法会在通过在源NetNode上执行Send动作，获得初始的链路信息。随后，将会在随后生成出的NetNode上执行Receive动作，不断产生新的链路和节点，直到整张链路图被构造完成。 "},{"title":"Plugin​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#plugin","content":"网络插件（flannel、calico等）。负责从网络配置中创建出实际的NetNode，作为NetNodeAction返回。 "},{"title":"NetNodeManager​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#netnodemanager","content":"创建并缓存NetNodeAction。通过CollectorManager采集Kubernetes pod/node网络栈信息后，通过Plugin创建出NetNodeAction。 "},{"title":"CollectorManager​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#collectormanager","content":"管理Kubernetes pod/nodes网络栈信息的采集任务。 "},{"title":"IPCache​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#ipcache","content":"缓存被诊断过程使用的主要Kubernetes对象，防止对API Server的冗余访问。 "},{"title":"NetNodeAction​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#netnodeaction","content":"代表NetNode上的网络动作的接口。任何NetNode都应当实现该接口。 "},{"title":"InfraShim​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#infrashim","content":"对基础设施提供的资源的断言。该部分应当根据不同的云提供商实现。 "},{"title":"service.Processor​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#serviceprocessor","content":"代表处理Service的组件（如kube-proxy）。它获得service的后端端点，并且根据网络栈信息来检查它们是否配置正确。 "},{"title":"(包)assertions​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#包assertions","content":"用于诊断中的断言。包括NetstackAssertion和KubernetesAssertion。 "},{"title":"(包)netstack​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#包netstack","content":"与Linux网络栈相关的组件和实用工具。包括Router、Netfilter、IPTables等。 "},{"title":"关键数据结构​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#关键数据结构","content":""},{"title":"Context​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#context","content":"type Context struct { Ctx *sync.Map }  Context 用于存储运行时配置。除此之外，它同时负责为各个模块绑定其所需的命令行参数，以及提供模块注册用的接口。 "},{"title":"Endpoint​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#endpoint","content":"type Endpoint struct { IP string Type EndpointType Port uint16 }  网络层面的端点，包括IP、Port、和Type。 "},{"title":"Packet​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#packet","content":"type Packet struct { Src net.IP Sport uint16 Dst net.IP Dport uint16 Protocol Protocol Encap *Packet Mark uint32 }  一个数据包。 Encap: 如果是一个被封装过的数据包（比如IPIP数据包），被封装的真实数据包储存于该字段。 Mark: 用于路由以及iptables模拟。 "},{"title":"NetNode​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#netnode","content":"type NetNode struct { Type NetNodeType ID string Actions map[*Link]*Action Suspicions []Suspicion initiative *Action }  网络链路图中的节点。它可以是Kubernets中的Pod或Node，也可以是云上的网络资源等。NetNode实现了NetNodeAction接口来处理网络流量，以及Assertion接口用来在节点上储存断言信息。 "},{"title":"Transmission​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#transmission","content":"type Transmission struct { NextHop Hop Link *Link }  NetNode上Send()或者Receive()动作创建出的一次传输请求。其中包括指向下一个NetNode的NetHop，以及描述了本次传输信息的Link。 "},{"title":"Hop​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#hop","content":"type Hop struct { Type NetNodeType ID string }  某一跳的信息，用于定位到某个NetNode。 "},{"title":"Link​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#link","content":"type Link struct { Type LinkType Source NetNodeAction Destination NetNodeAction Packet *Packet SourceAttribute LinkAttribute DestinationAttribute LinkAttribute Level int // for print } type LinkAttribute interface { GetAttrs() map[string]string }  两个节点之间的传输链路。 Type: 包括 external, vpc, veth, ipvlan, local等。 SourceAttribute&amp;DestinationAttribute: 在源节点和目的节点上，用于描述该条链路信息的键值对。 "},{"title":"k8s.Pod​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#k8spod","content":"type PodMeta struct { Namespace string PodName string NodeName string HostNetwork bool } type Pod struct { model.NetNode netstack.NetNS PodMeta }  Kubernetes上的Pod信息。包括Pod的元数据和网络栈数据。 "},{"title":"k8s.NodeInfo​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#k8snodeinfo","content":"type NodeInfo struct { netstack.NetNS SubNetNSInfo []netstack.NetNSInfo NodeMeta } type NodeNetworkStackDump struct { Pods []PodNetInfo `json:&quot;pods&quot;` Netns []netstack.NetNSInfo `json:&quot;netns&quot;` } type NodeMeta struct { NodeName string }  Kubernetes上的Node信息。包括Node的元数据，Node和Node上Pod的网络栈数据。 "},{"title":"Suspicion​","type":1,"pageTitle":"架构","url":"/zh/docs/contribute/diagnose/architecture#suspicion","content":"type Suspicion struct { Level SuspicionLevel Message string }  在 NetNode上出现的问题。 Level: 问题的严重程度。包括Info、Warning、Critical 和 Fatal。 Message: 问题描述。 "},{"title":"扩展KubeSkoop","type":0,"sectionRef":"#","url":"/zh/docs/contribute/extend-kubeskoop","content":"","keywords":""},{"title":"扩展KubeSkoop连通性诊断​","type":1,"pageTitle":"扩展KubeSkoop","url":"/zh/docs/contribute/extend-kubeskoop#扩展kubeskoop连通性诊断","content":"关键的组件和数据结构可以查看架构文档。 如果您想要为诊断添加新的插件或云厂商支持，可以参考添加新插件或添加新云提供商文档。 "},{"title":"扩展KubeSkoop深度网络监控​","type":1,"pageTitle":"扩展KubeSkoop","url":"/zh/docs/contribute/extend-kubeskoop#扩展kubeskoop深度网络监控","content":""},{"title":"指定云供应商","type":0,"sectionRef":"#","url":"/zh/docs/guide/diagnose/cloud-providers","content":"","keywords":""},{"title":"阿里云​","type":1,"pageTitle":"指定云供应商","url":"/zh/docs/guide/diagnose/cloud-providers#阿里云","content":"指定--cloud-provider aliyun以使用阿里云作为云提供商。 除了指定云提供商外，使用阿里云作为云提供商还需要提供以下参数： 参数\t说明--aliyun-access-key-id\t阿里云access key --aliyun-access-key-secret\t阿里云access secret --aliyun-security-token\t(可选)阿里云security token "},{"title":"命令行参数","type":0,"sectionRef":"#","url":"/zh/docs/guide/diagnose/command-line-arguments","content":"命令行参数 kubeskoop命令目前提供以下命令行参数。 参数\t说明-p, --dport uint16\t网络诊断的端口 -d, --dst string\t网络诊断的目的地址 --protocol string\t网络诊断的协议（默认tcp） -s, --src string\t网络诊断的源地址 --cloud-provider string\t云提供商名称（默认generic） --cluster-cidr string\t集群Pod CIDR。若没有指定，将会尝试自动探测。 --kube-config string\t集群kubeconfig路径（默认~/.kube/config） --network-plugin string\t集群网络插件。若没有指定，将会尝试自动探测 --proxy-mode string\tkube-proxy模式。若没有指定，将会尝试自动探测 --format string\t结果输出格式，支持dot/svg/json。若没有指定，只会在控制台打印简单链路信息 --http\t启动HTTP服务器来展示诊断结果 --http-address string\tHTTP服务器监听地址（默认127.0.0.1:8080） --output string\t输出结果保存文件路径，默认为当前目录下的output.dot/svg/json --aliyun-access-key-id string\t阿里云access key --aliyun-access-key-secret string\t阿里云access secret --aliyun-security-token string\t阿里云security token（可选） --collector-image string\tcollector所使用的镜像地址（默认registry.cn-hangzhou.aliyuncs.com/kubeskoop/kubeskoop:&lt;版本&gt;） --collector-namespace string\tcollector pod所在命名空间 （默认skoop） --collector-pod-wait-interval duration\tcollector pod运行检测时间间隔（默认2s） --collector-pod-wait-timeout duration\tcollector pod运行检测超时时间（默认2m0s） --calico-host-interface string\tCalico插件所使用的主机网络接口（默认eth0） --calico-ipip-pod-mtu int\tCalico插件所使用的Pod MTU，IPIP模式（默认1480） --calico-pod-mtu int\tCalico插件所使用的Pod MTU，BGP模式（默认1500） --flannel-backend-type string\tFlannel插件的模式，支持host-gw,vxlan,alloc。若没有指定，将会尝试从Flannel配置中自动探测 --flannel-bridge string\tFlannel插件的bridge设备名称（默认cni0） --flannel-host-interface string\tFlannel插件所使用的主机网络接口（默认eth0） --flannel-ip-masq\tFlannel插件，是否进行IP masquerade（默认true） --flannel-pod-mtu int\tFlannel插件所使用的Pod MTU。若没有指定，将会根据模式自动设定（vxlan默认1450, 其它模式1500）","keywords":""},{"title":"展示/保存诊断结果","type":0,"sectionRef":"#","url":"/zh/docs/guide/diagnose/diagnosis-result","content":"","keywords":""},{"title":"输出格式​","type":1,"pageTitle":"展示/保存诊断结果","url":"/zh/docs/guide/diagnose/diagnosis-result#输出格式","content":"当前支持dot、svg、json输出格式，在诊断时加入--format参数指定使用哪种格式输出结果。使用--output来指定输出文件名，可以指定为-表示输出到标准输出。 若没有指定任何格式，诊断结束后，将会在标准输出中输出简单链路信息和诊断结果。 "},{"title":"dot​","type":1,"pageTitle":"展示/保存诊断结果","url":"/zh/docs/guide/diagnose/diagnosis-result#dot","content":"输出格式为dot。关于dot语法格式的更多说明，请见文档。 该输出格式仅包含生成的链路信息，不携带诊断结果。 "},{"title":"svg​","type":1,"pageTitle":"展示/保存诊断结果","url":"/zh/docs/guide/diagnose/diagnosis-result#svg","content":"输出格式为svg，由graphviz通过dot文件生成。 该输出格式仅包含生成的链路信息，不携带诊断结果。 "},{"title":"json​","type":1,"pageTitle":"展示/保存诊断结果","url":"/zh/docs/guide/diagnose/diagnosis-result#json","content":"输出格式为json。json中包含链路图中的节点和边的详细信息，以及节点上的诊断结果。 "},{"title":"简介","type":0,"sectionRef":"#","url":"/zh/docs/guide/diagnose/intro","content":"","keywords":""},{"title":"快速开始​","type":1,"pageTitle":"简介","url":"/zh/docs/guide/diagnose/intro#快速开始","content":""},{"title":"诊断命令安装​","type":1,"pageTitle":"简介","url":"/zh/docs/guide/diagnose/intro#诊断命令安装","content":"通过go install来安装KubeSkoop的诊断客户端： go install github.com/alibaba/kubeskoop/cmd/skoop@latest  "},{"title":"一键诊断​","type":1,"pageTitle":"简介","url":"/zh/docs/guide/diagnose/intro#一键诊断","content":"$ skoop -s 172.18.0.4 -d 10.96.0.10 -p 53 --http # 执行诊断命令，指定来源目的，通过--http来让诊断结果通过本地web服务提供 I0118 11:43:23.383446 6280 web.go:97] HTTP server listening on http://127.0.0.1:8080 # 诊断完成会输出诊断结果链接  之后，通过浏览器打开http://127.0.0.1:8080查看诊断结果。 "},{"title":"工作原理​","type":1,"pageTitle":"简介","url":"/zh/docs/guide/diagnose/intro#工作原理","content":"KubeSkoop连通性诊断根据集群中所使用的插件和所使用的云供应商，构造从源地址到目的地址的链路图，并且对节点进行网络信息的采集（如iptables规则、网络设备信息、sysctls等）。 在构造链路的过程中，会对图中的节点和边的信息进行校验和模拟。若预期情况与实际情况不符，则认为网络配置错误。 "},{"title":"使用限制​","type":1,"pageTitle":"简介","url":"/zh/docs/guide/diagnose/intro#使用限制","content":"KubeSkoop网络诊断只支持对已实现的网络插件进行诊断，详细信息请见网络插件。 "},{"title":"支持的网络插件","type":0,"sectionRef":"#","url":"/zh/docs/guide/diagnose/network-plugins","content":"","keywords":""},{"title":"Flannel​","type":1,"pageTitle":"支持的网络插件","url":"/zh/docs/guide/diagnose/network-plugins#flannel","content":"支持host-gw和vxlan模式的连通性诊断，会在运行时自动检测所使用的类型。 "},{"title":"Calico​","type":1,"pageTitle":"支持的网络插件","url":"/zh/docs/guide/diagnose/network-plugins#calico","content":"支持BGP以及IPIP模式的连通性诊断，会在运行时自动检测所使用的类型。 注：Calico诊断正常运行需要集群内安装Calico API Server组件。更多信息，可见Calico文档。 "},{"title":"添加新插件","type":0,"sectionRef":"#","url":"/zh/docs/contribute/diagnose/new-plugin","content":"","keywords":""},{"title":"实现 Plugin​","type":1,"pageTitle":"添加新插件","url":"/zh/docs/contribute/diagnose/new-plugin#实现-plugin","content":"所有插件的实现都位于pkg/skoop/plugin。 插件应当实现Plugin接口。 type Plugin interface { CreatePod(pod *k8s.Pod) (model.NetNodeAction, error) CreateNode(node *k8s.NodeInfo) (model.NetNodeAction, error) }  CreatePod(): 接受*k8s.Pod作为参数，创建对应的Pod实现，作为NetNodeAction类型返回。 CreateNode(): 接受*k8s.NodeInfo作为参数，创建对应的Node实现，作为NetNodeAction返回。 你应当根据你的插件，为Pod和Node提供相应的实现。 NetNodeAction的定义如下： type NetNodeAction interface { Send(dst Endpoint, protocol Protocol) ([]Transmission, error) Receive(upstream *Link) ([]Transmission, error) }  Send()代表从节点上发送一个数据包。接受目的端点以及协议作为参数，并返回[]Transsmision作为结果。Receive()代表在节点上接受一个数据包。接受*Link类型的上游作为参数，并返回[]Transsmision作为结果。 使用veth网卡对作为Pod的网络接口是一种很常见的情况。在这种情况下，你可以通过调用newSimpleVethPod()，直接使用simpleVethPod作为Pod的实现。比如： func (f *flannelPlugin) CreatePod(pod *k8s.Pod) (model.NetNodeAction, error) { return newSimpleVEthPod(pod, f.ipCache, f.podMTU, &quot;eth0&quot;) }  对于Node的实现，你可能需要判断网络端点的类型（Pod、Node、Service还是External）。通常来说，你可以直接使用BasePluginNode作为NetNodeAction的实现，并且实现SimplePluginNode接口。 type SimplePluginNode interface { ToPod(upstream *model.Link, dst model.Endpoint, protocol model.Protocol, pod *v1.Pod) ([]model.Transmission, error) ToHost(upstream *model.Link, dst model.Endpoint, protocol model.Protocol, node *v1.Node) ([]model.Transmission, error) ToService(upstream *model.Link, dst model.Endpoint, protocol model.Protocol, service *v1.Service) ([]model.Transmission, error) ToExternal(upstream *model.Link, dst model.Endpoint, protocol model.Protocol) ([]model.Transmission, error) Serve(upstream *model.Link, dst model.Endpoint, protocol model.Protocol) ([]model.Transmission, error) }  SimplePluginNode已经根据端点类型对动作进行了分类。以Flannel插件的实现举例： func (f *flannelPlugin) CreateNode(node *k8s.NodeInfo) (model.NetNodeAction, error) { flannelHost, err := newFlannelHost(f.ipCache, node, f.infraShim, f.serviceProcessor, f.hostOptions) if err != nil { return nil, err } return &amp;BasePluginNode{ NetNode: flannelHost.netNode, IPCache: f.ipCache, SimplePluginNode: flannelHost, }, nil }  在实现过程中，你可能会用到IPCache或NetsatckAssertion等工具来帮助你获得某个资源的信息，或是检查网络配置是否正确。关于此的详细信息，你可以参考Flannel插件的的实现，位于pkg/skoop/plugin/flannel.go。 如果你需要为你的插件添加命令行参数，你需要实现ConfigBinder，并将其注册到程序中。 type CalicoConfig struct { PodMTU int IPIPPodMTU int Interface string } func (c *CalicoConfig) BindFlags(fs *pflag.FlagSet) { fs.StringVarP(&amp;c.Interface, &quot;calico-host-interface&quot;, &quot;&quot;, &quot;eth0&quot;, &quot;Host interface for calico plugin.&quot;) fs.IntVarP(&amp;c.PodMTU, &quot;calico-pod-mtu&quot;, &quot;&quot;, 1500, &quot;Pod MTU for calico plugin. Pod interface MTU in BGP mode.&quot;) fs.IntVarP(&amp;c.IPIPPodMTU, &quot;calico-ipip-pod-mtu&quot;, &quot;&quot;, 1480, &quot;Pod MTU for calico plugin. Pod interface MTU in IPIP mode.&quot;) } func (c *CalicoConfig) Validate() error { return nil } var Calico = &amp;CalicoConfig{} func init() { ctx.RegisterConfigBinder(&quot;Calico plugin&quot;, Calico) }  "},{"title":"实现 Network​","type":1,"pageTitle":"添加新插件","url":"/zh/docs/contribute/diagnose/new-plugin#实现-network","content":"Network 位于pkg/skoop/network中。 type Network interface { Diagnose(ctx *ctx.Context, src model.Endpoint, dst model.Endpoint) ([]model.Suspicion, *model.PacketPath, error) }  Diagnose(): 接受*ctx.Context、*model.Endpoint类型的源和目的地址，返回 []model.Suspicion 和*model.PacketPath作为返回值。 Network是云提供商特定的，特定的实现位于pkg/skoop/network/&lt;提供商名称&gt;/. 如果你的插件支持该提供商，你就需要为其添加Network的实现。网络类型generic代表任意云提供商，所以你至少为这个网络类型提供你的插件的Network实现。 Plugin、NetNodeManager、NetworkPolicy、service.Processor和Diagnostor会在Network创建时被配置好。如： func NewFlannelNetwork(ctx *ctx.Context) (network.Network, error) { serviceProcessor := service.NewKubeProxyServiceProcessor(ctx) plgn, err := plugin.NewFlannelPlugin(ctx, serviceProcessor, nil) if err != nil { return nil, err } collectorManager, err := manager.NewSimplePodCollectorManager(ctx) if err != nil { return nil, err } netNodeManager, err := nodemanager.NewNetNodeManager(ctx, plgn, collectorManager) if err != nil { return nil, err } networkPolicy, err := plugin.NewNetworkPolicy(false, false, ctx.ClusterConfig().IPCache, ctx.KubernetesClient(), serviceProcessor) if err != nil { return nil, err } diagnostor, err := skoop.NewDefaultDiagnostor(ctx, netNodeManager, networkPolicy) if err != nil { return nil, err } return &amp;flannelNetwork{ plugin: plgn, diagnostor: diagnostor, collectorManager: collectorManager, netNodeManager: netNodeManager, }, nil }  "},{"title":"添加新的插件类型并在Provider中创建​","type":1,"pageTitle":"添加新插件","url":"/zh/docs/contribute/diagnose/new-plugin#添加新的插件类型并在provider中创建","content":"插件类型的定义在pkg/skoop/context/cluster.go中。你应当在这里添加一个新的类型。 const ( NetworkPluginFlannel = &quot;flannel&quot; NetworkPluginCalico = &quot;calico&quot; NetworkPluginTerway = &quot;terway&quot; // 在这里添加新的插件类型 )  在这之后，你还需要为所支持的云提供商创建你的插件，文件位于pkg/skoop/provider/&lt;提供商名称&gt;.go。示例如下： func (g genericProvider) CreateNetwork(ctx *context.Context) (network.Network, error) { switch ctx.ClusterConfig().NetworkPlugin { case context.NetworkPluginFlannel: return generic.NewFlannelNetwork(ctx) case context.NetworkPluginCalico: return generic.NewCalicoNetwork(ctx) // add your plugin type default: return nil, fmt.Errorf(&quot;not support cni type %q&quot;, ctx.ClusterConfig().NetworkPlugin) } }  现在，你可以在命令行参数中指定--network plugin &lt;插件名&gt;来使用你的插件。 "},{"title":"添加插件自动探测​","type":1,"pageTitle":"添加新插件","url":"/zh/docs/contribute/diagnose/new-plugin#添加插件自动探测","content":"你可以在pkg/utils/k8s.go的DetectNetworkPlugin()文件中，通过遍历集群中的DaemonSet的方式来添加插件类型的自动探测。 func DetectNetworkPlugin(k8sCli *kubernetes.Clientset) (networkMode string, err error) { dss, err := k8sCli.AppsV1().DaemonSets(&quot;&quot;).List(context.Background(), metav1.ListOptions{}) if err != nil { return &quot;&quot;, err } for _, ds := range dss.Items { switch ds.Name { case &quot;kube-flannel-ds&quot;: return &quot;flannel&quot;, nil case &quot;calico-node&quot;: return &quot;calico&quot;, nil case &quot;terway-eniip&quot;: return &quot;terway-eniip&quot;, nil } } return &quot;&quot;, nil }  "},{"title":"添加e2e测试​","type":1,"pageTitle":"添加新插件","url":"/zh/docs/contribute/diagnose/new-plugin#添加e2e测试","content":"最后，你应当在test/skoop/e2e/testcase/plugins.go中添加插件相关的测试用例，并且将你的插件添加到test/skoop/e2e/testcase/testcases.go文件中。 "},{"title":"安装 KubeSkoop exporter","type":0,"sectionRef":"#","url":"/zh/docs/guide/exporter/exporter_installation","content":"","keywords":""},{"title":"安装依赖​","type":1,"pageTitle":"安装 KubeSkoop exporter","url":"/zh/docs/guide/exporter/exporter_installation#安装依赖","content":"Linux kernel &gt;= 4.9.17 （在低版本内核上可以支持部分功能）基于Docker/Containerd/Pouch的容器运行时 "},{"title":"快速安装​","type":1,"pageTitle":"安装 KubeSkoop exporter","url":"/zh/docs/guide/exporter/exporter_installation#快速安装","content":""},{"title":"快速体验KubeSkoop exporter功能​","type":1,"pageTitle":"安装 KubeSkoop exporter","url":"/zh/docs/guide/exporter/exporter_installation#快速体验kubeskoop-exporter功能","content":"KubeSkoop exporter提供了一个可以快速部署的配置，包含以下组件： KubeSkoop exporter组件。单副本的Prometheus组件与Grafana组件，Grafana Loki组件。Prometheus和Grafana的NodePort服务。 通过以下步骤，可以在Kubernetes集群中快速部署KubeSkoop exporter及其与Prometheus，Grafana和Loki构成的可观测性组合： kubectl apply -f https://github.com/alibaba/kubeskoop/deploy/skoopbundle.yaml  通过以下步骤，确认安装完成以及获取访问入口： # 查看Skoop exporter的运行状态 kubectl get pod -n kubeskoop -l app=skoop-exporter -o wide # 查看Probe采集探针的运行状态 kubectl get --raw /api/v1/namespaces/{{skoop-exporter的pod namespace}}/pods/{{skoop-exporter的pod name}}:9102/proxy/status |jq . # 获取Prometheus服务的入口 kubectl get service -n kubeskoop prometheus-service -o wide # 获取Grafana控制台的访问入口 kubectl get service -n kubeskoop grafana -o wide  "},{"title":"仅安装KubeSkoop exporter​","type":1,"pageTitle":"安装 KubeSkoop exporter","url":"/zh/docs/guide/exporter/exporter_installation#仅安装kubeskoop-exporter","content":"通过以下步骤，可以在Kubernetes集群中快速部署KubeSkoop exporter： kubectl apply -f https://github.com/alibaba/kubeskoop/deploy/kubeskoopexporter.yaml  "},{"title":"使用Helm安装​","type":1,"pageTitle":"安装 KubeSkoop exporter","url":"/zh/docs/guide/exporter/exporter_installation#使用helm安装","content":"# 添加skoop charts repo helm repo add kubeskoop https://github.com/alibaba/kubeskoop/charts # 首次执行时，需要更新helm repo缓存 helm repo update # 安装skoop exporter helm install skoop-exporter kubeskoop/skoop-exporter  如果需要调试Helm Charts信息，可以通过本地安装： # 获取skoop exporter代码仓库 git clone https://github.com/alibaba/kubeskoop.git # 进行本地安装 helm install --set namespace=kube-system skoop-exporter ./kubeskoop/deploy/skoop-exporter-0.1.0.tgz --debug  Skoop-exporter以DaemonSet方式部署在集群中，可以通过以下方式验证是否正常工作： # 查看Skoop exporter的运行状态 kubectl get pod -n skoop -l app=skoop-exporter -o wide # 获取到pod的信息后，可以通过apiserver查看Probe采集探针的运行状态 kubectl get --raw /api/v1/namespaces/{{skoop-exporter的pod namespace}}/pods/{{skoop-exporter的pod name}}:9102/proxy/status |jq . # 如果可以直接访问skoop-exporter实例，也可以直接查看Probe的运行状态 curl {{skoop-exporter的pod ip}}:9102/status |jq .  "},{"title":"Helm配置​","type":1,"pageTitle":"安装 KubeSkoop exporter","url":"/zh/docs/guide/exporter/exporter_installation#helm配置","content":"通过helm安装KubeSkoop exporter时，可以配置的参数如下： 配置项\t配置说明\t默认配置name\tKubeSkoop exporter的组件名称\tskoop-exporter namespace\tKubeSkoop exporter的命名空间\tkubeskoop debugmode\t调试模式的开关，打开调试模式后，可以获得更详细的日志以及开启pprof和gops接口\tfalse config.enableEventServer\t事件采集服务的开关\tfalse config.enableMetricServer\t监控指标服务的开关\ttrue config.remoteLokiAddress\t开启事件采集服务后，通过这个选项配置需要推送事件的Grafana Loki服务地址\t`` config.metricLabelVerbose\t获取更加详细的监控指标标签，包括Pod的app标签，ip地址等\tfalse config.metricServerPort\t监控指标服务的端口，提供http服务\t9102 config.eventServerPort\tKubeSkoop exporter的GRPC服务端口，提供事件流服务\t19102 config.metricProbes\t配置开启的监控指标探针 config.eventProbes\t配置开启的事件采集探针 config.metricCacheInterval\t监控指标的采集缓存周期，单位为秒\t15 "},{"title":"安装完成校验​","type":1,"pageTitle":"安装 KubeSkoop exporter","url":"/zh/docs/guide/exporter/exporter_installation#安装完成校验","content":"通过helm方式完成KubeSkoop exporter的安装后，可以通过以下方式验证是否正常运行: # 查看Probe采集探针的运行状态 kubectl get --raw /api/v1/namespaces/{{KubeSkoop exporter的pod namespace}}/pods/{{KubeSkoop exporter的pod name}}:9102/proxy/status |jq .  "},{"title":"配置​","type":1,"pageTitle":"安装 KubeSkoop exporter","url":"/zh/docs/guide/exporter/exporter_installation#配置","content":"KubeSkoop exporter的配置是默认由与workload相同命名空间下的ConfigMap对象inspector-config进行管理，通过以下方式可以进行修改： # 修改命名空间为实际生效的命名空间 kubectl edit cm -n kubeskoop inspector-config  KubeSkoop exporter支持的配置项如下: 配置项\t配置功能\t默认值debugmode\t调试模式的开关，打开调试模式后，可以获得更详细的日志以及开启pprof和gops接口\tfalse event_config.loki_enable\t事件采集服务推向给Grafana Loki的开关\tfalse event_config.loki_address\t开启事件采集服务后，通过这个选项配置需要推送事件的Grafana Loki服务地址\t`` event_config.probes\t配置开启的事件采集探针 event_config.port\tKubeSkoop exporter的GRPC服务端口，提供事件流服务\t19102 metric_config.verbose\t获取更加详细的监控指标标签，包括Pod的app标签，ip地址等\tfalse metric_config.port\t监控指标服务的端口，提供http服务\t9102 metric_config.probes\t配置开启的监控指标探针 metric_config.interval\t监控指标的采集缓存周期，单位为秒\t15 可以选择配置的探针信息可以参考KubeSkoop exporter 功能简介 "},{"title":"KubeSkoop exporter 功能简介","type":0,"sectionRef":"#","url":"/zh/docs/guide/exporter/exporter-description","content":"","keywords":""},{"title":"概述​","type":1,"pageTitle":"KubeSkoop exporter 功能简介","url":"/zh/docs/guide/exporter/exporter-description#概述","content":"KubeSkoop exporter是面向Kubernetes云原生环境的网络监控工具，可以提供以下功能： 针对Pod级别的网络监控，包括流量，应用层连接信息，socket内存分配状态等针对Pod级别的网络异常状态的指标监控，例如Pod内进程对socket进行读写操作的等待时间超过100ms的次数，Pod发出TCP rst报文的次数等针对Pod级别的网络异常事件的现场，提供事件发生的详细信息的观测，例如内核网络软中断调度等待过久，UDP出现socket内存不足导致的溢出等 与常见的Kubernetes监控和可观测性工具的主要区别如下： 功能选项\tPrometheus Node exporter\tcAdvisor/Metric API\tKubeSkoop exporter按照Pod区分\tNo\tYes\tYes 网络状态监控\tYes\tNo\tYes 异常事件的现场捕获\tNo\tNo\tYes 内核网络高阶信息\tNo\tYes\tYes "},{"title":"核心原理​","type":1,"pageTitle":"KubeSkoop exporter 功能简介","url":"/zh/docs/guide/exporter/exporter-description#核心原理","content":""},{"title":"架构​","type":1,"pageTitle":"KubeSkoop exporter 功能简介","url":"/zh/docs/guide/exporter/exporter-description#架构","content":" "},{"title":"信息采集​","type":1,"pageTitle":"KubeSkoop exporter 功能简介","url":"/zh/docs/guide/exporter/exporter-description#信息采集","content":"KubeSkoop exporter提供了适配于Kubernetes网络监控功能，在节点上，KubeSkoop exporter采集并归类了网络相关的大量数据，实现这些功能的核心原理包括: 通过CRI接口和Linux /proc/获取节点内的网络隔离状态及其与Pod的关联信息通过Linux /proc/，Linux netlink和eBPF获取网络监控信息通过eBPF获取操作系统内核在网络异常事件发生时的上下文状态 "},{"title":"聚合分析​","type":1,"pageTitle":"KubeSkoop exporter 功能简介","url":"/zh/docs/guide/exporter/exporter-description#聚合分析","content":"KubeSkoop exporter采集的数据可以通过多种方式获取，包括: 通过Prometheus获取监控信息，并使用Grafana进行可视化操作通过配置Grafana Loki接收KubeSkoop exporter的事件推送，并使用Grafana进行可视化操作使用kubeskoop inspector命令行工具观察监控信息 关于如何将监控数据进行可视化，请参考KubeSkoop exporter 可视化配置 "},{"title":"指标信息​","type":1,"pageTitle":"KubeSkoop exporter 功能简介","url":"/zh/docs/guide/exporter/exporter-description#指标信息","content":"KubeSkoop exporter 提供Pod级别的指标信息来反应实例运行过程中的环境变化，指标按照来源和用户，分类到不同的探针他们的相关信息如下: 探针名称\t功能描述\t数据源netdev\t从容器的/proc/net/dev文件中采集的网络设备流量数据\tprocfs io\t从容器的/proc/io文件中采集的io相关的系统调用数据\tprocfs tcp\t从容器的/proc/net/snmp文件中采集的tcp协议统计数据\tprocfs softnet\t从容器的/proc/net/softnet文件中采集的softnet报文收发统计数据\tprocfs sock\t节点的socket分配和内存占用情况统计\tprocfs tcpext\t从容器的/proc/net/netstat文件中采集的tcp协议统计数据\tprocfs udp\t从容器的/proc/net/snmp采集的udp协议统计数据\tprocfs tcpsummary\ttcp协议连接和数据堆积统计数据\tnetlink ip\t从容器的/proc/net/snmp文件中采集的ip协议统计数据\tprocfs socketlatency\tPod中的进程进行socket相关的读写操作的耗时统计数据\teBPF net_softirq\t节点的网络相关的软中断的调度和执行耗时统计数据\teBPF virtcmdlatency\tVirtio-net驱动前端向物理机后端发送消息的耗时统计数据\teBPF kernellatency\t内核协议栈处理报文的耗时统计数据\teBPF netiftxlat\t网络数据包在网卡队列和数据发送阶段等待的耗时统计\teBPF packetloss\t操作系统内核丢弃的网络数据包情况统计\teBPF "},{"title":"网络异常事件信息​","type":1,"pageTitle":"KubeSkoop exporter 功能简介","url":"/zh/docs/guide/exporter/exporter-description#网络异常事件信息","content":"KubeSkoop exporter 提供节点上发生的网络相关的异常事件，根据在长期处理网络问题中的经验，我们归纳了几种常见的网络疑难问题，他们往往在集群中以无法复现，偶然发生的方式干扰正常的业务，缺乏有效的定位手段，其中部分如下： 网络数据报文被丢弃引发的连接失败，响应超时等问题。网络数据处理耗时久引发的偶发性能问题。TCP，conntrack等状态机制异常引发的业务异常问题。 针对无法快速复现和难以获取现场的网络问题，KubeSkoop exporter提供了基于eBPF的操作系统内核上下文观测能力，在问题发生的现场捕获操作系统的实时状态，以事件日志的方式输出。 KubeSkoop exporter 内置支持的事件如下： 探针名称\t功能描述netiftxlat\t探测网络数据包发送时在tc qdisc等待延迟高的事件 packetloss\t操作系统内核丢弃正常的网络数据包的事件 net_softirq\t操作系统软中断内核进程关于NET_RX/NET_TX中断下半部的调度或执行延迟高的事件 socketlatency\tPod中的进程进行socket相关的读写操作的耗时久的事件 kernellatency\t内核在网络层处理报文耗时久的事件 virtcmdlatency\tVirtio-net与宿主机通信耗时久的事件 tcpreset\t接收或发出TCP协议中带有RST标记的报文的事件 tcptwrcv\tTCP协议在TIMEWAIT状态下收到了报文并处理的事件 tcpretrans ｜ TCP协议出现重传的事件 在事件日志的信息中，可以查看到事件现场的相关信息，以tcp_reset探针为例，当出现有Pod收到了一个访问为止端口的正常报文时，KubeSkoop exporter会捕获以下事件信息: type=TCPRESET_NOSOCK pod=storage-monitor-5775dfdc77-fj767 namespace=kube-system protocol=TCP saddr=100.103.42.233 sport=443 daddr=10.1.17.188 dport=33488  事件中的信息如下： type表明出现了一次TCPRESET_NOSOCK类型的事件，这是tcpreset探针捕获的一种事件，他表明有访问为止端口的报文被本地发送RST报文拒绝，拒绝的原因是没有根据报文找到相应的socket，通常在NAT失效，如ipvs定时器超时等原因发生后，会伴随这个事件。pod/namespace是KubeSkoop exporter根据发送报文的网络命名空间，ip地址和网络设备序号进行匹配后关联给事件的Pod元信息。saddr/sport/daddr/dport是KubeSkoop exporter在内核获取到的异常报文的信息，随着事件的不同，这部分信息也会有差异，例如net_softirq探针的事件信息中没有ip地址，取而代之的是中断发生的CPU序号，产生的延迟时长等。 对于需要有效的操作系统内核堆栈信息的事件，可以通过配置开关来额外获取操作系统内核的协议栈信息，这会增加一定的消耗，从而获取到更加精准的现象，例如： type=PACKETLOSS pod=hostNetwork namespace=hostNetwork protocol=TCP saddr=10.1.17.172 sport=6443 daddr=10.1.17.176 dport=43018 stacktrace:skb_release_data+0xA3 __kfree_skb+0xE tcp_recvmsg+0x61D inet_recvmsg+0x58 sock_read_iter+0x92 new_sync_read+0xE8 vfs_read+0x89 ksys_read+0x5A  "},{"title":"KubeSkoop exporter 可视化配置","type":0,"sectionRef":"#","url":"/zh/docs/guide/exporter/exporter-visualization-guide","content":"","keywords":""},{"title":"使用 Prometheus & Grafana 进行指标的可视化​","type":1,"pageTitle":"KubeSkoop exporter 可视化配置","url":"/zh/docs/guide/exporter/exporter-visualization-guide#使用-prometheus--grafana-进行指标的可视化","content":"KubeSkoop exporter提供了标准的Prometheus格式的指标输出服务，您可以快速将KubeSkoop exporter的监控信息集成到已有的监控系统中，请参考 配置 。 如果没有就绪的监控服务，请参考 安装 搭建可视化的监控服务。 "},{"title":"安装​","type":1,"pageTitle":"KubeSkoop exporter 可视化配置","url":"/zh/docs/guide/exporter/exporter-visualization-guide#安装","content":"参考 Prometheus 的安装 完成Prometheus的部署安装。 参考 Grafana 的安装 完成Grafana的安装并配置与Prometheus的连接。 "},{"title":"配置KubeSkoop exporter指标监控​","type":1,"pageTitle":"KubeSkoop exporter 可视化配置","url":"/zh/docs/guide/exporter/exporter-visualization-guide#配置kubeskoop-exporter指标监控","content":"KubeSkoop exporter支持运行在kubernetes中的prometheus的服务发现功能，在安装完成prometheus之后，可以通过Status-&gt;Targets页面，在搜索栏中输入skoop-exporter，查看已经就绪的实例:  在KubeSkoop exporter实例被prometheus正常捕获后，可以通过以下步骤完成指标的可视化操作： 进入Grafana的控制台，点击Configuration-&gt;Data sources-&gt;Add data source后选择Prometheus，将已经就绪的prometheus实例的地址添加到Grafana的数据源订阅中:新建一个大盘，或者在已有大盘中选择新建一个面板，在面板的配置中选取数据源为1中配置的数据源，并在Metric browser中输入inspector，即可看到联想后的KubeSkoop exporter指标，选取其中需要的信息，以inspector_pod_netdevrxbytes为例，输入完成后，可以在面板中看到获取到的数据。在指标的可视化中，可以根据需要设置指标的图例和单位等信息，其中，图例支持配置Pod的Namespace，ip，label等信息，在面板的Legend中可以配置这些支持的图例。 "},{"title":"导入预定义默认大盘​","type":1,"pageTitle":"KubeSkoop exporter 可视化配置","url":"/zh/docs/guide/exporter/exporter-visualization-guide#导入预定义默认大盘","content":"KubeSkoop exporter提供跟随版本更新的默认Grafana大盘配置文件: curl https://raw.githubusercontent.com/alibaba/kubeskoop/main/deploy/resource/kubeskoop-exporter-dashboard.json -o dashboard.json  登陆Grafana控制台后，点击Dashboards-&gt;Import-&gt;Upload JSON file，选择保存好的文件上传后，选取prometheus作为数据源，点击Import导入，即可查看到默认大盘。通过选取不同的面板组，可以查看到不同类别的监控指标信息:  "},{"title":"使用 Grafana & Loki 查看可视化的网络事件​","type":1,"pageTitle":"KubeSkoop exporter 可视化配置","url":"/zh/docs/guide/exporter/exporter-visualization-guide#使用-grafana--loki-查看可视化的网络事件","content":""},{"title":"安装 Grafana Loki​","type":1,"pageTitle":"KubeSkoop exporter 可视化配置","url":"/zh/docs/guide/exporter/exporter-visualization-guide#安装-grafana-loki","content":"按照官方文档进行不同场景下的 Grafana Loki的安装。 安装完成后，可以通过以下方式检查Grafana Loki的可用性: curl http://[Grafana Loki实例的地址]:3100/ready  "},{"title":"配置kubeskoop exporter事件流​","type":1,"pageTitle":"KubeSkoop exporter 可视化配置","url":"/zh/docs/guide/exporter/exporter-visualization-guide#配置kubeskoop-exporter事件流","content":"通过Grafana​ 通过Grafana可以将KubeSkoop exporter推送到Grafana Loki的事件进行可视化，通过以下步骤可以实现实现可视化操作： 点击Configuration-&gt;Data sources-&gt;Add data source后选择Loki，将Grafana Loki服务的地址添加到Grafana的数据源订阅中，可以是ip地址和域名，默认端口为3100：新建一个大盘，或者在已有大盘中选择新建一个面板，在面板的配置中选取数据源为1中配置的数据源，并在Label browser中过滤需要的事件信息：在事件面板中，可以通过LogQL查询特定的事件，点击事件后，可以看到详细的现场信息: "},{"title":"简介","type":0,"sectionRef":"#","url":"/zh/docs/guide/intro","content":"","keywords":""},{"title":"Connectivity diagnose​","type":1,"pageTitle":"简介","url":"/zh/docs/guide/intro#connectivity-diagnose","content":""},{"title":"Monitoring​","type":1,"pageTitle":"简介","url":"/zh/docs/guide/intro#monitoring","content":""},{"title":"简介","type":0,"sectionRef":"#","url":"/zh/docs/intro","content":"","keywords":""},{"title":"总览​","type":1,"pageTitle":"简介","url":"/zh/docs/intro#总览","content":"KubeSkoop 是一个Kubernetes网络诊断工具. 针对不同的网络插件和IaaS提供商自动构建Kubernetes集群中Pod的网络访问图，结合eBPF对内核关键路径的深度监控和分析，来分析常见的Kubernetes集群网络问题。 显著地简化了Kubernetes网络问题的诊断难度。 "},{"title":"关键特性​","type":1,"pageTitle":"简介","url":"/zh/docs/intro#关键特性","content":""},{"title":"一键诊断网络链路​","type":1,"pageTitle":"简介","url":"/zh/docs/intro#一键诊断网络链路","content":"诊断kubernetes集群中各种网络访问方式和链路：Pod,Service,Node and Ingress/Egress Traffic.覆盖完整的Linux协议栈的配置错误场景: Socket,Bridge,Veth,Netfilter,sysctls…支持诊断多种云供应商的IAAS层网络错误配置 "},{"title":"深度网络监控​","type":1,"pageTitle":"简介","url":"/zh/docs/intro#深度网络监控","content":"通过eBPF实现无侵入的Kernel Montor通过BTF在各种版本的Kernel上直接运行通过标准的Prometheus接口暴露深度监控Metrics "},{"title":"网络异常事件识别​","type":1,"pageTitle":"简介","url":"/zh/docs/intro#网络异常事件识别","content":"几十种网络异常场景自动分析识别通过 Grafana Loki 展示网络异常事件 Contributing Feel free to open issues and pull requests. Any feedback is much appreciated! Contact DingTalk Group ID(26720020148) License Most source code in KubeSkoop which running on userspace are licensed under the Apache License, Version 2.0. The BPF code in /bpf directory are licensed under the GPL v2.0 to compact with Linux kernel helper functions. "},{"title":"Roadmap","type":0,"sectionRef":"#","url":"/zh/docs/roadmap","content":"Roadmap kubeskoop roadmap","keywords":""},{"title":"快速上手","type":0,"sectionRef":"#","url":"/zh/docs/quick-start","content":"","keywords":""},{"title":"网络问题分类​","type":1,"pageTitle":"快速上手","url":"/zh/docs/quick-start#网络问题分类","content":"持续的网络不通 大部分的网络持续不通问题都是网络链路中的错误配置导致的，比如 iptables规则、VM的安全组条目缺失等。 KubeSkoop通过分析 src-&gt;dst 的链路生成出流量的图，然后对图上的节点和边做规则的校验和模拟来实现网络错误配置的定位。 偶发的网络抖动 网络链路中的偶发的包延迟、丢失、重传等经常会导致业务的抖动问题，由于是偶发的，导致问题很难回溯和定位根因。 KubeSkoop通过eBPF深度监控内核中协议栈关键路径，综合多指标关联出典型抖动场景，记录和回溯网络的异常根因。 网络性能瓶颈 应用网络依赖通常关联链路很多，例如上下游服务、DNS解析等，性能上不去时很难分析根因。 KubeSkoop通过对应用关联链路和应用层瓶颈分析，找出影响性能的关键链路。 "},{"title":"诊断网络不通问题​","type":1,"pageTitle":"快速上手","url":"/zh/docs/quick-start#诊断网络不通问题","content":""},{"title":"诊断命令安装​","type":1,"pageTitle":"快速上手","url":"/zh/docs/quick-start#诊断命令安装","content":"通过go install来安装KubeSkoop的诊断客户端： go install github.com/alibaba/kubeskoop/cmd/skoop@latest  "},{"title":"一键诊断​","type":1,"pageTitle":"快速上手","url":"/zh/docs/quick-start#一键诊断","content":"$ skoop -s 172.18.0.4 -d 10.96.0.10 -p 53 --http # 执行诊断命令，指定来源目的，通过--http来让诊断结果通过本地web服务提供 I0118 11:43:23.383446 6280 web.go:97] HTTP server listening on http://127.0.0.1:8080 # 诊断完成会输出诊断结果链接  通过浏览器打来http://127.0.0.1:8080后可以看到诊断结果： "},{"title":"诊断网络抖动和网络性能问题​","type":1,"pageTitle":"快速上手","url":"/zh/docs/quick-start#诊断网络抖动和网络性能问题","content":""},{"title":"安装网络监控组件​","type":1,"pageTitle":"快速上手","url":"/zh/docs/quick-start#安装网络监控组件","content":"通过以下步骤，可以在Kubernetes集群中快速部署Skoop exporter及其与Prometheus，Grafana和Loki构成的可观测性组合： kubectl apply -f https://raw.githubusercontent.com/alibaba/kubeskoop/main/deploy/skoopbundle.yaml  通过以下步骤，确认安装完成以及获取访问入口： # 查看Skoop exporter的运行状态 kubectl get pod -n kubeskoop -l app=skoop-exporter -o wide # 查看Probe采集探针的运行状态 kubectl get --raw /api/v1/namespaces/kubeskoop/pods/skoop-exporter-t4d9m:9102/proxy/status |jq . # 获取Prometheus服务的入口 kubectl get service -n kubeskoop prometheus-service -o wide # 获取Grafana控制台的访问入口 kubectl get service -n kubeskoop grafana -o wide  备注: skoopbundle.yaml以最小副本方式启动，不适用于生产环境 "},{"title":"查看网络抖动和性能分析​","type":1,"pageTitle":"快速上手","url":"/zh/docs/quick-start#查看网络抖动和性能分析","content":"网络性能分析​ 打开grafana的Service访问入口，打开网络监控的页面，查看对应性能问题时间点的各深度指标的水位情况。例如： 具体指标说明参考文档: Kubeskoop exporter 功能简介  网络抖动事件​ 打开grafana的Service访问入口，打开Loki的页面，查看对应网络抖动时间点对应的事件，以及网络监控页面对应的水位情况。 具体指标和事件说明参考文档：Kubeskoop exporter 功能简介  "}]