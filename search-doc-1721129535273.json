[{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":""},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":""},{"title":"Code Overview","type":0,"sectionRef":"#","url":"/docs/contribute/code-overview","content":"","keywords":""},{"title":"High level​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#high-level","content":""},{"title":"bpf​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#bpf","content":"The eBPF code and headers used by exporter. "},{"title":"cmd​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#cmd","content":"CLI programs. "},{"title":"deploy​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#deploy","content":"Helm charts and manifests for deploying KubeSkoop. "},{"title":"docs​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#docs","content":"Documentation. "},{"title":"pkg​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkg","content":"Common go packages. "},{"title":"rpc​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#rpc","content":"gRPC definitions used by exporter. "},{"title":"test​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#test","content":"E2E tests. "},{"title":"KubeSkoop diagnosis​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#kubeskoop-diagnosis","content":""},{"title":"cmd/skoop​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#cmdskoop","content":"skoop command. "},{"title":"cmd/collector​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#cmdcollector","content":"collector command. "},{"title":"pkg/skoop/cmd​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopcmd","content":"Main logic of skoop CLI command. "},{"title":"pkg/skoop/assertions​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopassertions","content":"Assertion type definitions and common assertion utils, including kubernetes and netstack. "},{"title":"pkg/skoop/collector​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopcollector","content":"Definitions and implementation of collector command and CollectorManager . "},{"title":"pkg/skoop/context​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopcontext","content":"Runtime context of the program, providing cluster or task information for the diagnosis. It also provides command flags parsing, and allow other package to register their flags. "},{"title":"pkg/skoop/infra​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopinfra","content":"Implementation of cloud providers. "},{"title":"pkg/skoop/k8s​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopk8s","content":"Definitions and utilities for components of Kubernetes cluster. "},{"title":"pkg/skoop/model​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopmodel","content":"Definitions of models used for diagnosis, including Packet, Link, Action, etc. "},{"title":"pkg/skoop/netstack​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopnetstack","content":"Definitions and parser of Linux network stack, like route, IPVS, and iptables simulation. "},{"title":"pkg/skoop/network​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopnetwork","content":"Implementations of Network . "},{"title":"pkg/skoop/nodemanager​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopnodemanager","content":"Implementation of NetNodeManager "},{"title":"pkg/skoop/plugin​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopplugin","content":"Implementations of Plugin, including flannel, calico, etc. "},{"title":"pkg/skoop/provider​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopprovider","content":"Implementations of Provider, including generic, aliyun, etc. "},{"title":"pkg/skoop/service​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopservice","content":"Implementations of ServiceProcessor, including kube-proxy. "},{"title":"pkg/skoop/skoop​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopskoop","content":"Implementations of Diagnostor. "},{"title":"pkg/skoop/ui​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskoopui","content":"Output formatter and Web UI. "},{"title":"pkg/skoop/utils​","type":1,"pageTitle":"Code Overview","url":"/docs/contribute/code-overview#pkgskooputils","content":"Utilities. "},{"title":"Extend KubeSkoop","type":0,"sectionRef":"#","url":"/docs/contribute/extend-kubeskoop","content":"","keywords":""},{"title":"Extend KubeSkoop diagnosis​","type":1,"pageTitle":"Extend KubeSkoop","url":"/docs/contribute/extend-kubeskoop#extend-kubeskoop-diagnosis","content":"The key components and structures a described in Architecture. If you are going to add a new plugin or a new cloud provider support for the diagnosis, you can refer to Add a new plugin or Add a new cloud provider. "},{"title":"Extend KubeSkoop exporter​","type":1,"pageTitle":"Extend KubeSkoop","url":"/docs/contribute/extend-kubeskoop#extend-kubeskoop-exporter","content":""},{"title":"Architecture","type":0,"sectionRef":"#","url":"/docs/contribute/connectivity-diagnosis/architecture","content":"","keywords":""},{"title":"Key components​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#key-components","content":""},{"title":"Provider​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#provider","content":"Abstraction of cloud provider, responsible for detecting network type and creating Network. "},{"title":"Network​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#network","content":"Cloud-specific container network. A Network should configure all resources that the diagnosis progress needs, including Plugin, Diagnostor, InfraShim, etc. "},{"title":"Diagnostor​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#diagnostor","content":"Implementation of the diagnosis algorithm. It generates the initial links and nodes on source NetNode by executing Send action, and continuously generates new links and nodes by executing Receive action on later added NetNode, until the entire graph has been constructed. "},{"title":"Plugin​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#plugin","content":"Network plugin(flannel, calico, etc.). It creates the actual NetNode from the network config and return NetNodeAction. "},{"title":"NetNodeManager​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#netnodemanager","content":"Create and cache NetNodeAction. It collects Kubernetes pod/node netstack info from CollectorManager, and create NetNodeAction from Plugin. "},{"title":"CollectorManager​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#collectormanager","content":"Manage collect tasks, which collect netstack info of Kubernetes pod/nodes. "},{"title":"IPCache​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#ipcache","content":"Cache major Kubernetes objects used by diagnosis, to prevent redundant access to the API Server. "},{"title":"NetNodeAction​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#netnodeaction","content":"An interface represents the network action of a NetNode. It should be implemented by any NetNode type. "},{"title":"InfraShim​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#infrashim","content":"Assertions of infra resources. Should be implemented by cloud providers. "},{"title":"service.Processor​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#serviceprocessor","content":"The component stands for a service processor (like kube-proxy). It gets the backends of a service, and check its configuration in from netstack info. "},{"title":"(Package)assertions​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#packageassertions","content":"Assertion utilities for diagnosis. Including NetstackAssertion and KubernetesAssertion. "},{"title":"(Package)netstack​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#packagenetstack","content":"Components and utilities of the Linux netstack. Including Router, Netfilter, IPTables, etc. "},{"title":"Key structures​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#key-structures","content":""},{"title":"Context​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#context","content":"type Context struct { Ctx *sync.Map }  Context is used to store runtime configurations. It is responsible for binding flags for modules and providing interfaces for registration. "},{"title":"Endpoint​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#endpoint","content":"type Endpoint struct { IP string Type EndpointType Port uint16 }  Endpoint for the network layer, including IP, Port and Type. "},{"title":"Packet​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#packet","content":"type Packet struct { Src net.IP Sport uint16 Dst net.IP Dport uint16 Protocol Protocol Encap *Packet Mark uint32 }  A data packet. Encap: If the packet is an encapsuled packet (such as an IPIP packet), the real packet is in this field. Mark: Used in router and iptables simulation. "},{"title":"NetNode​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#netnode","content":"type NetNode struct { Type NetNodeType ID string Actions map[*Link]*Action Suspicions []Suspicion initiative *Action }  Node in the network graph. It can be Pod or Node in Kubernetes, or can also be a network resources on the cloud. NetNode implements NetNodeAction for handle network traffic, and Assertion for storing assertions. "},{"title":"Transmission​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#transmission","content":"type Transmission struct { NextHop Hop Link *Link }  A transmit operation created by Send() or Receive() action of a NetNode. It contains NextHop pointing to the next NetNode, and Link to describe the transmission info. "},{"title":"Hop​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#hop","content":"type Hop struct { Type NetNodeType ID string }  Information for a hop, used to find a NetNode. "},{"title":"Link​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#link","content":"type Link struct { Type LinkType Source NetNodeAction Destination NetNodeAction Packet *Packet SourceAttribute LinkAttribute DestinationAttribute LinkAttribute Level int // for print } type LinkAttribute interface { GetAttrs() map[string]string }  The link between two nodes. Type: Contains external, vpc, veth, ipvlan, local, and more. SourceAttribute&amp;DestinationAttribute: The key-value attributes of this link on source and destination nodes. "},{"title":"k8s.Pod​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#k8spod","content":"type PodMeta struct { Namespace string PodName string NodeName string HostNetwork bool } type Pod struct { model.NetNode netstack.NetNS PodMeta }  Information for a Pod of Kubernetes. Includes Pod's metadata and netstack info. "},{"title":"k8s.NodeInfo​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#k8snodeinfo","content":"type NodeInfo struct { netstack.NetNS SubNetNSInfo []netstack.NetNSInfo NodeMeta } type NodeNetworkStackDump struct { Pods []PodNetInfo `json:&quot;pods&quot;` Netns []netstack.NetNSInfo `json:&quot;netns&quot;` } type NodeMeta struct { NodeName string }  Information for a Node of Kubernetes. Includes Node's metadata and netstack info of node and pods on it. "},{"title":"Suspicion​","type":1,"pageTitle":"Architecture","url":"/docs/contribute/connectivity-diagnosis/architecture#suspicion","content":"type Suspicion struct { Level SuspicionLevel Message string }  The problem occurred on a NetNode. Level: Severity of the problem. Contains Info, Warning, Critical and Fatal. Message: Problem description. "},{"title":"Requirements","type":0,"sectionRef":"#","url":"/docs/getting-started/requirements","content":"","keywords":""},{"title":"Connectivity Diagnosis​","type":1,"pageTitle":"Requirements","url":"/docs/getting-started/requirements#connectivity-diagnosis","content":"Connectivity Diagnosis relies on the network plugin you are using has already been implemented, and you can see a list of currently supported network plugins [here] (.../reference/connectivity-diagnosis/network-plugins.md) to see a list of currently supported network plugins. To also perform diagnostics for configurations on the cloud, you can find a list of currently supported network plugins at [here](... /reference/connectivity-diagnosis/cloud-providers.md) to find the list of implemented cloud providers. "},{"title":"System Kernel requirements​","type":1,"pageTitle":"Requirements","url":"/docs/getting-started/requirements#system-kernel-requirements","content":"KubeSkoop leverages eBPF technology as the core implementation of the observation capability. Therefore, when using the network monitoring capabilities of KubeSkoop, it is required that the kernel version of the Kubernetes cluster nodes should be 4.9.17 and above. "},{"title":"Add a new cloud provider","type":0,"sectionRef":"#","url":"/docs/contribute/connectivity-diagnosis/new-cloud-provider","content":"","keywords":""},{"title":"Implement InfraShim​","type":1,"pageTitle":"Add a new cloud provider","url":"/docs/contribute/connectivity-diagnosis/new-cloud-provider#implement-infrashim","content":"InfraShim is used for checking configuration of the underlying infra network. type InfraShim interface { NodeToNode(src *v1.Node, oif string, dst *v1.Node, packet *model.Packet) ([]model.Suspicion, error) NodeToExternal(src *v1.Node, oif string, packet *model.Packet) ([]model.Suspicion, error) }  NodeToNode(): Transmission between two nodes. Accepts kubernetes *v1.Node for source and destination, output interface name, and *model.Packet. Returns []model.Suspicions as result. NodeToExternal() : Transmission from node to external network (eg. internet). Accepts kubernetes *v1.Node for source, output interface name and *model.Packet. Returns []model.Suspicions as result. InfraShim is responsible to check whether the packet can reach its destination in the underlying network, for example, an address in intranet but outside of the cluster should check routes and security groups rules, or an address in internet should check NAT entries. InfraShim should be implemented in pkg/skoop/network/&lt;provider name&gt;. "},{"title":"Implement Network​","type":1,"pageTitle":"Add a new cloud provider","url":"/docs/contribute/connectivity-diagnosis/new-cloud-provider#implement-network","content":"Network are also located in pkg/skoop/network/&lt;provider name&gt;.They are both cloud provider specified and plugin specified, so you should implement your own Network for supported plugins. type Network interface { Diagnose(ctx *ctx.Context, src model.Endpoint, dst model.Endpoint) ([]model.Suspicion, *model.PacketPath, error) }  Diagnose(): accepts *ctx.Context, source and destination as *model.Endpoint. Returns []model.Suspicion and *model.PacketPath. A Network should configure all resources that a diagnosis progress needs, including Plugin, Diagnostor, InfraShim, etc. "},{"title":"Add new Provider​","type":1,"pageTitle":"Add a new cloud provider","url":"/docs/contribute/connectivity-diagnosis/new-cloud-provider#add-new-provider","content":"Provider are located in pkg/skoop/provider. type Provider interface { CreateNetwork(ctx *ctx.Context) (network.Network, error) }  CreateNetwork(): accepts *ctx.Context and returns network.Network. The implementation of Provider is simple: check the plugin type, and create corresponding Network. type genericProvider struct { } func (g genericProvider) CreateNetwork(ctx *context.Context) (network.Network, error) { switch ctx.ClusterConfig().NetworkPlugin { case context.NetworkPluginFlannel: return generic.NewFlannelNetwork(ctx) case context.NetworkPluginCalico: return generic.NewCalicoNetwork(ctx) default: return nil, fmt.Errorf(&quot;not support cni type %q&quot;, ctx.ClusterConfig().NetworkPlugin) } }  You should implement your Provider in pkg/skoop/provider/&lt;provider name&gt;.go. Then, a new provider type constant need to be added in pkg/skoop/provider/provider.go. const ( providerNameGeneric = &quot;generic&quot; providerNameAliyun = &quot;aliyun&quot; // add new provider name here )  This constant value will be used in the command line arguments At last, add your implementation to providers. var providers = map[string]Provider{ providerNameGeneric: genericProvider{}, providerNameAliyun: aliyunProvider{}, // add new provider }  "},{"title":"Components used by cloud providers​","type":1,"pageTitle":"Add a new cloud provider","url":"/docs/contribute/connectivity-diagnosis/new-cloud-provider#components-used-by-cloud-providers","content":"Cloud provider related components are located in pkg/skoop/infra/&lt;provider name&gt;. Such as config, or cloud client. If you want to add any flags for your plugin, you should implement ConfigBinder, and register it. For example in pkg/skoop/infra/aliyun/config.go. type ProviderConfig struct { AccessKeyID string AccessKeySecret string SecurityToken string } var Config = &amp;ProviderConfig{} func init() { context.RegisterConfigBinder(&quot;Aliyun provider&quot;, Config) } func (pc *ProviderConfig) BindFlags(fs *pflag.FlagSet) { fs.StringVarP(&amp;pc.AccessKeyID, &quot;aliyun-access-key-id&quot;, &quot;&quot;, &quot;&quot;, &quot;Aliyun access key.&quot;) fs.StringVarP(&amp;pc.AccessKeySecret, &quot;aliyun-access-key-secret&quot;, &quot;&quot;, &quot;&quot;, &quot;Aliyun access secret.&quot;) fs.StringVarP(&amp;pc.SecurityToken, &quot;aliyun-security-token&quot;, &quot;&quot;, &quot;&quot;, &quot;Aliyun security token (optional).&quot;) } func (pc *ProviderConfig) Validate() error { return nil }  "},{"title":"Configuration","type":0,"sectionRef":"#","url":"/docs/guide/configuration","content":"","keywords":""},{"title":"Configuration Hot Reload​","type":1,"pageTitle":"Configuration","url":"/docs/guide/configuration#configuration-hot-reload","content":"KubeSkoop agent supports hot reloading of configurations, when configuration file changes, KubeSkoop will automatically reloads it. "},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/getting-started/installation","content":"","keywords":""},{"title":"Install via Helm​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/installation#install-via-helm","content":"You can install production-ready KubeSkoop instance by Helm. Execute the following command to add the KubeSkoop repository to Helm and install KubeSkoop: # Add kubeskoop repo helm repo add kubeskoop https://kubeskoop.io/ # Upgrade helm repo helm repo update # Install kubeskoop helm install -n kubeskoop kubeskoop kubeskoop/kubeskoop  The command will install KubeSkoop into the kubeskoop namespace and turn on the agent, controller and webconsole components of KubeSkoop by default. "},{"title":"Customize Configuration​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/installation#customize-configuration","content":"You can view the values that can be configured by executing the following command. helm show values kubeskoop/kubeskoop  You can save the values to the values.yaml file, make changes to the parameters you need, and then install KubeSkoop with theses values. # If you have already installed KubeSkoop, you can upgrade it with `helm upgrade`. helm install -f values.yaml -n kubeskoop kubeskoop kubeskoop/kubeskoop  You can also use the --set parameter to customize the configuration. helm install --set controller.config.prometheusEndpoint=http://prometheus -n kubeskoop kubeskoop kubeskoop/kubeskoop  "},{"title":"Configure Probes​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/installation#configure-probes","content":"In the config section of the values, you can configure the metrics/event probes that need to be turned on. The default configuration is as follows: config: metricProbes: - name: conntrack - name: qdisc - name: netdev - name: io - name: sock - name: tcpsummary - name: tcp - name: tcpext - name: udp - name: kernellatency - name: packetloss - name: flow args: enablePortInLabel: false - name: tcpretrans eventProbes: - name: biolatency - name: kernellatency - name: packetloss args: enableStack: false - name: tcpreset - name: tcpretrans eventSinks: - name: stderr  For more information about the probes, please see the documentation. "},{"title":"Configure Prometheus and Loki Endpoint​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/installation#configure-prometheus-and-loki-endpoint","content":"Some features (e.g., network graph, anomaly events) of Web Console relies on Prometheus and Loki. You need to provide the endpoint for the Prometheus and Loki services during installation. tip If there is no ready-to-use Prometheus or Loki instances, you can refer to theses documentations: Refer to Prometheus Installation to complete the deployment and installation of Prometheus.Refer to Install Grafana Loki with Helm to complete the deployment and installation of Loki. Configure prometheusEndpoint and lokiEndpoint in the controller.config section. Assuming that prometheus and loki are installed in the monitoring namespace, and the service names are prometheus and loki, a sample configuration is as follows: controller: enabled: true config: # configure endpoint address for prometheus. prometheusEndpoint: 'http://prometheus.monitoring:9090' # configure endpoint address for loki. lokiEndpoint: 'http://loki.monitoring:3100'  At the same time, the event sinks needs to be configured in config.eventSink so that events can be collected via Loki. config: # ...some probe configurations eventSinks: - name: stderr # configure loki event sink and specify the address as the service address of loki. - name: loki args: addr: 'http://loki.monitoring:3100'  Finally, install/update KubeSkoop via helm install or helm upgrade. "},{"title":"Use CLI","type":0,"sectionRef":"#","url":"/docs/guide/connectivity-diagnosis/use-cli","content":"","keywords":""},{"title":"Diagnose the cluster​","type":1,"pageTitle":"Use CLI","url":"/docs/guide/connectivity-diagnosis/use-cli#diagnose-the-cluster","content":"Execute the following command to make a connectivity diagnosis task from 172.18.0.4 to 10.96.0.10, port 80, and TCP protocol(by default). skoop -s 172.18.0.4 -d 10.96.0.10 -p 80  When the diagnosis is complete, the packet path and the problems found will be output to the screen. $ skoop -s 172.18.0.4 -d 10.96.0.10 -p 53 Packet path: &quot;default/netshoot-6bddd57fb7-49q9s&quot; -&gt; &quot;node1&quot; [label=&quot;type=veth,level=0,trans=service,oif=eth0,iif=cni0,src=172.18.0.4,dst=10.96.0.10,dport=53&quot;] &quot;node1&quot; -&gt; &quot;kube-system/coredns-547b98dbcc-dxmnl&quot; [label=&quot;type=veth,level=1,trans=serve,oif=cni0,iif=eth0,src=172.18.0.4,dst=172.18.0.2,dport=53&quot;,arrowhead=&quot;dot&quot;] &quot;node1&quot; -&gt; &quot;node2&quot; [label=&quot;type=infra,level=1,trans=forward,oif=eth0,iif=eth0,src=172.18.0.4,dst=172.18.0.69,dport=53&quot;] &quot;node2&quot; -&gt; &quot;kube-system/coredns-547b98dbcc-zr2zl&quot; [label=&quot;type=veth,level=2,trans=serve,oif=cni0,iif=eth0,src=172.18.0.4,dst=172.18.0.69,dport=53&quot;,arrowhead=&quot;dot&quot;] Suspicions on node &quot;kube-system/coredns-547b98dbcc-zr2zl&quot; [FATAL] no process listening on 0.0.0.0:80 or 172.18.0.69:80 protocol tcp  "},{"title":"View diagnosis result through web​","type":1,"pageTitle":"Use CLI","url":"/docs/guide/connectivity-diagnosis/use-cli#view-diagnosis-result-through-web","content":"By adding the --http parameter to the command line, an HTTP server will be launched for viewing the diagnosis results interactively. When the --http parameter is used, after the diagnosis completed, an HTTP server is started to accept requests at the specified address, which you can open to view the link graph and final results. $ skoop -s 172.18.0.4 -d 10.96.0.10 -p 53 --http I0118 11:43:23.383446 6280 web.go:97] HTTP server listening on http://127.0.0.1:8080  The server is started on 127.0.0.1:8080 by default, you can also specify the address with the --http-address parameter. tip If you are running diagnostics in Docker container or on a remote server, you may need to set --http-address to 0.0.0.0:8080 for remote address access. Take Docker as an example: docker run -p 8080:8080 -v ~/.kube:/root/.kube kubeskoop/kubeskoop:latest skoop -s 172.18.0.4 -d 10.96.0.10 -p 80 --http --http-address=0.0.0.0:8080  After opening http://127.0.0.1:8080 through your browser, you can see the diagnostic results:  "},{"title":"Output format​","type":1,"pageTitle":"Use CLI","url":"/docs/guide/connectivity-diagnosis/use-cli#output-format","content":"You can specify the output format with the --format parameter. If you do not specify the output format, it will output simple link information and diagnostic results in the standard output by default when the diagnosis is finished. Currently, d2, svg, json output is supported. In addition, you can use --output to specify the output filename (defaults to result.d2/svg/json), and can also specify - to indicate output to standard output. "},{"title":"d2​","type":1,"pageTitle":"Use CLI","url":"/docs/guide/connectivity-diagnosis/use-cli#d2","content":"Output format d2. For more information about d2 syntax, please refer to the documentation. This output format contains only the generated link information and does not contain the diagnosis result. "},{"title":"svg​","type":1,"pageTitle":"Use CLI","url":"/docs/guide/connectivity-diagnosis/use-cli#svg","content":"Output format svg, generated by d2 file. This output format contains only the generated link information and does not contain the diagnosis result. "},{"title":"json​","type":1,"pageTitle":"Use CLI","url":"/docs/guide/connectivity-diagnosis/use-cli#json","content":"Output format json. The json output format contains details of the nodes and edges in the link graph, as well as the diagnosis result in cluster. "},{"title":"Specify the cloud provider​","type":1,"pageTitle":"Use CLI","url":"/docs/guide/connectivity-diagnosis/use-cli#specify-the-cloud-provider","content":"KubeSkoop supports specifying the cloud provider to provide diagnosis for resource configuration on the cloud. After specifying the cloud provider via the --cloud-provider parameter, Connectivity Diagnostics will check the on-cloud resource configurations such as VM security groups, routing tables, NAT, etc. Currently supported cloud providers and the extra arguments needed, please refer to the documentation. "},{"title":"Other command line arguments​","type":1,"pageTitle":"Use CLI","url":"/docs/guide/connectivity-diagnosis/use-cli#other-command-line-arguments","content":"You can use the --help parameter to see the rest of the parameters and their usage, or refer to the documentation. "},{"title":"Latency Detection","type":0,"sectionRef":"#","url":"/docs/guide/latency-detection","content":"","keywords":""},{"title":"Start Latency Detection Task​","type":1,"pageTitle":"Latency Detection","url":"/docs/guide/latency-detection#start-latency-detection-task","content":""},{"title":"Add Targets​","type":1,"pageTitle":"Latency Detection","url":"/docs/guide/latency-detection#add-targets","content":"By clicking the Add button of Targets, you can add packet capturing targets via the target selector.  In the Add Target window, you can add Node or Pod as the target. You can add single Pod/Node by its namespace &amp; name, or add multiple targets by label selector. "},{"title":"View Result​","type":1,"pageTitle":"Latency Detection","url":"/docs/guide/latency-detection#view-result","content":"After the latency detection task is finished, you can view the link graph in Result.  In the link graph, you can see the connection status between nodes by the color of the connecting lines between nodes, and the average latency between nodes is also displayed on the connecting lines. You can also hover your mouse over the connection to view the connection details. "},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/guide/monitoring/intro","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Intro","url":"/docs/guide/monitoring/intro#overview","content":"KubeSkoop provides the following features: Pod-level network monitoring, including traffic, application layer connection information, socket memory allocation status, and more.Metrics monitoring for network abnormal states at the Pod level, such as the number of times a Pod's process waits for more than 100ms to read or write to a socket, the number of times a Pod issues TCP RST packets, and so on.At the Pod level, provide on-site observation of network abnormal events and detailed information on the occurrence of events, such as the kernel network soft interrupt scheduling waiting too long, UDP overflow caused by socket memory shortage, and more. The main differences from common Kubernetes monitoring and observability tools are as follows: Features\tPrometheus Node exporter\tcAdvisor/Metric API\tKubeSkoop exporterBy Pod differentiation\tNo\tYes\tYes Network status monitoring\tYes\tNo\tYes On-site capture of abnormal events\tNo\tNo\tYes Advanced kernel network information\tNo\tYes\tYes "},{"title":"Introduction​","type":1,"pageTitle":"Intro","url":"/docs/guide/monitoring/intro#introduction","content":""},{"title":"Architecture​","type":1,"pageTitle":"Intro","url":"/docs/guide/monitoring/intro#architecture","content":" "},{"title":"Information gathering​","type":1,"pageTitle":"Intro","url":"/docs/guide/monitoring/intro#information-gathering","content":"KubeSkoop exporter provides adaptation for Kubernetes network monitoring function. On the nodes, KubeSkoop exporter collects and categorizes a large amount of network-related data. The core principle behind these functions includes: Obtaining the network isolation status within the node and its association with Pods through the CRI interface and Linux /proc/.Obtaining network monitoring information through Linux /proc/, Linux netlink, and eBPF.Obtaining the contextual state of the operating system kernel during network anomaly events through eBPF. "},{"title":"Aggregated analysis​","type":1,"pageTitle":"Intro","url":"/docs/guide/monitoring/intro#aggregated-analysis","content":"Scraping monitoring information through Prometheus and visualizing it using Grafana.Configuring Grafana Loki to receive event push from KubeSkoop exporter and visualizing it using Grafana.Using the KubeSkoop inspector command-line tool to observe monitoring information. Regarding how to visualize monitoring data, please refer to visualization "},{"title":"Metrics​","type":1,"pageTitle":"Intro","url":"/docs/guide/monitoring/intro#metrics","content":"KubeSkoop exporter provides Pod-level metric information to reflect environmental changes during instance operation, and exposes the metrics via Prometheus. "},{"title":"Events​","type":1,"pageTitle":"Intro","url":"/docs/guide/monitoring/intro#events","content":"KubeSkoop exporter provides network-related abnormal events occurring on the nodes. Based on our experience in handling network issues in the long-term, we have summarized several common network troubleshooting problems. They often interfere with normal business operations in the cluster in an unpredictable and occasional manner, lacking effective localization methods. Some of them are as follows: Connection failure, response timeout, and other issues caused by discarded network packets.Occasional performance issues caused by longer processing time for network data.Task abnormality issues caused by TCP, conntrack, and other stateful abnormalities. For network issues that are difficult to quickly reproduce and obtain on-site, KubeSkoop exporter provides eBPF-based operating system kernel context observation capabilities to capture the real-time state of the operating system at the scene of the problem and output it in the form of event logs. In the information of the event log, relevant information of the event scene can be viewed. Taking the tcp_reset probe as an example, when a Pod receives a normal message on a certain port, KubeSkoop exporter will capture the following event information: type=TCPRESET_NOSOCK pod=storage-monitor-5775dfdc77-fj767 namespace=kube-system protocol=TCP saddr=100.103.42.233 sport=443 daddr=10.1.17.188 dport=33488  For events that require effective operating system kernel stack information, additional protocol stack information of the operating system kernel can be obtained by configuring the switch, which will increase certain costs and obtain more accurate phenomena, for example: type=PACKETLOSS pod=hostNetwork namespace=hostNetwork protocol=TCP saddr=10.1.17.172 sport=6443 daddr=10.1.17.176 dport=43018 stacktrace:skb_release_data+0xA3 __kfree_skb+0xE tcp_recvmsg+0x61D inet_recvmsg+0x58 sock_read_iter+0x92 new_sync_read+0xE8 vfs_read+0x89 ksys_read+0x5A  info For list for currently supported probes, metrics and events, please refer to Probes, Metrics and Events. "},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/guide/connectivity-diagnosis/intro","content":"","keywords":""},{"title":"How it works​","type":1,"pageTitle":"Intro","url":"/docs/guide/connectivity-diagnosis/intro#how-it-works","content":"When run KubeSkoop connectivity diagnosis, it generates traffic graph from source address to destination address by the network plugin and cloud provider of your cluster. Then, it collects network stack information (iptables rules, network device info, sysctls, etc.) on nodes. When build traffic links, it will evaluate links and edges in the graph to check whether it works as expected. If not, it will be considered as a misconfiguration. "},{"title":"Use Connectivity Diagnosis​","type":1,"pageTitle":"Intro","url":"/docs/guide/connectivity-diagnosis/intro#use-connectivity-diagnosis","content":""},{"title":"via Web Console​","type":1,"pageTitle":"Intro","url":"/docs/guide/connectivity-diagnosis/intro#via-web-console","content":"Connectivity diagnostics can be triggered on web console.  "},{"title":"via CLI​","type":1,"pageTitle":"Intro","url":"/docs/guide/connectivity-diagnosis/intro#via-cli","content":"See Use CLI. "},{"title":"Limitations​","type":1,"pageTitle":"Intro","url":"/docs/guide/connectivity-diagnosis/intro#limitations","content":"KubeSkoop connectivity diagnosis feature relies on the implementation of the network plugin the cluster is using, and you can find it here to see a list of currently supported network plugins. To also diagnose for configurations on the cloud, you can find a list of implemented cloud providers here. "},{"title":"Network Graph","type":0,"sectionRef":"#","url":"/docs/guide/network-graph","content":"","keywords":""},{"title":"Show network graph from historical time range​","type":1,"pageTitle":"Network Graph","url":"/docs/guide/network-graph#show-network-graph-from-historical-time-range","content":"The Time Range selector allows you to query link information from a particular time range from history. "},{"title":"Filter endpoints by namespaces​","type":1,"pageTitle":"Network Graph","url":"/docs/guide/network-graph#filter-endpoints-by-namespaces","content":"You can filter endpoints by namespaces using the Namespaces selector. If no selection is made, endpoints under all namespaces are displayed by default. "},{"title":"Expand and collapse nodes​","type":1,"pageTitle":"Network Graph","url":"/docs/guide/network-graph#expand-and-collapse-nodes","content":"You can expand node by clicking it to see detailed information for every node in the group. You can also collapse nodes by clicking the expanded nodes again. "},{"title":"View detailed link information​","type":1,"pageTitle":"Network Graph","url":"/docs/guide/network-graph#view-detailed-link-information","content":"By switching ViewMode to Table mode, detailed link information can be viewed in table. In addition to the source and destination nodes, more details such as IP, port, connection traffic, etc. are displayed.  "},{"title":"Add a new plugin","type":0,"sectionRef":"#","url":"/docs/contribute/connectivity-diagnosis/new-plugin","content":"","keywords":""},{"title":"Implement Plugin​","type":1,"pageTitle":"Add a new plugin","url":"/docs/contribute/connectivity-diagnosis/new-plugin#implement-plugin","content":"All plugins are located in pkg/skoop/plugin. A plugin should implement interface Plugin. type Plugin interface { CreatePod(pod *k8s.Pod) (model.NetNodeAction, error) CreateNode(node *k8s.NodeInfo) (model.NetNodeAction, error) }  CreatePod(): accepts *k8s.Pod and creates pod implementation as NetNodeAction. CreateNode(): accepts *k8s.NodeInfo and creates node implementation as NetNodeAction You should provide implementations for pod and node based on your plugin. The definition of NetNodeAction is as follows: type NetNodeAction interface { Send(dst Endpoint, protocol Protocol) ([]Transmission, error) Receive(upstream *Link) ([]Transmission, error) }  Send() represents the operation of sending a packet from the node. It accepts destination endpoint and protocol, and returns []Transmission as the result.Receive() represents the operation of receiving a packet on the node. It accepts upstream as *Link, and returns []Transmission as the result. It's quite common to use veth pair as the network interface of pod. In this case, you can use simpleVethPod as implementation of pod by newSimpleVethPod(). For example: func (f *flannelPlugin) CreatePod(pod *k8s.Pod) (model.NetNodeAction, error) { return newSimpleVEthPod(pod, f.ipCache, f.podMTU, &quot;eth0&quot;) }  For node implementations, you may have to determine the type of an Endpoint (Pod, Node, Service, or External). For general, you can use BasePluginNode as NetNodeAction, and implement SimplePluginNode for it. type SimplePluginNode interface { ToPod(upstream *model.Link, dst model.Endpoint, protocol model.Protocol, pod *v1.Pod) ([]model.Transmission, error) ToHost(upstream *model.Link, dst model.Endpoint, protocol model.Protocol, node *v1.Node) ([]model.Transmission, error) ToService(upstream *model.Link, dst model.Endpoint, protocol model.Protocol, service *v1.Service) ([]model.Transmission, error) ToExternal(upstream *model.Link, dst model.Endpoint, protocol model.Protocol) ([]model.Transmission, error) Serve(upstream *model.Link, dst model.Endpoint, protocol model.Protocol) ([]model.Transmission, error) }  SimplePluginNode has already classified actions according to endpoint types. Take Flannel plugin as an example: func (f *flannelPlugin) CreateNode(node *k8s.NodeInfo) (model.NetNodeAction, error) { flannelHost, err := newFlannelHost(f.ipCache, node, f.infraShim, f.serviceProcessor, f.hostOptions) if err != nil { return nil, err } return &amp;BasePluginNode{ NetNode: flannelHost.netNode, IPCache: f.ipCache, SimplePluginNode: flannelHost, }, nil }  During implementation, you may need to use utilities such as IPCache and NetstackAssertion to help you get the information of a resource, or check its network configuration. For more details, you can refer to the implementation of the Flannel plugin in pkg/skoop/plugin/flannel.go. If you want to add any flags for your plugin, you should implement ConfigBinder, and register it. type CalicoConfig struct { PodMTU int IPIPPodMTU int Interface string } func (c *CalicoConfig) BindFlags(fs *pflag.FlagSet) { fs.StringVarP(&amp;c.Interface, &quot;calico-host-interface&quot;, &quot;&quot;, &quot;eth0&quot;, &quot;Host interface for calico plugin.&quot;) fs.IntVarP(&amp;c.PodMTU, &quot;calico-pod-mtu&quot;, &quot;&quot;, 1500, &quot;Pod MTU for calico plugin. Pod interface MTU in BGP mode.&quot;) fs.IntVarP(&amp;c.IPIPPodMTU, &quot;calico-ipip-pod-mtu&quot;, &quot;&quot;, 1480, &quot;Pod MTU for calico plugin. Pod interface MTU in IPIP mode.&quot;) } func (c *CalicoConfig) Validate() error { return nil } var Calico = &amp;CalicoConfig{} func init() { ctx.RegisterConfigBinder(&quot;Calico plugin&quot;, Calico) }  "},{"title":"Implement Network​","type":1,"pageTitle":"Add a new plugin","url":"/docs/contribute/connectivity-diagnosis/new-plugin#implement-network","content":"Network are located in pkg/skoop/network. type Network interface { Diagnose(ctx *ctx.Context, src model.Endpoint, dst model.Endpoint) ([]model.Suspicion, *model.PacketPath, error) }  Diagnose(): accepts *ctx.Context, source and destination as *model.Endpoint. Returns []model.Suspicion and *model.PacketPath. Network are cloud provider specified, and these implementations are located in pkg/skoop/network/&lt;provider name&gt;/. If your plugins are supported on this provider, you should add Networkimplementation for it. Network type generic stands for any cloud provider, so you should at least include your plugin's Network implementation in it. Plugin, NetNodeManager, NetworkPolicy, service.Processor and Diagnostor are configured during the creation of Network. For example: func NewFlannelNetwork(ctx *ctx.Context) (network.Network, error) { serviceProcessor := service.NewKubeProxyServiceProcessor(ctx) plgn, err := plugin.NewFlannelPlugin(ctx, serviceProcessor, nil) if err != nil { return nil, err } collectorManager, err := manager.NewSimplePodCollectorManager(ctx) if err != nil { return nil, err } netNodeManager, err := nodemanager.NewNetNodeManager(ctx, plgn, collectorManager) if err != nil { return nil, err } networkPolicy, err := plugin.NewNetworkPolicy(false, false, ctx.ClusterConfig().IPCache, ctx.KubernetesClient(), serviceProcessor) if err != nil { return nil, err } diagnostor, err := skoop.NewDefaultDiagnostor(ctx, netNodeManager, networkPolicy) if err != nil { return nil, err } return &amp;flannelNetwork{ plugin: plgn, diagnostor: diagnostor, collectorManager: collectorManager, netNodeManager: netNodeManager, }, nil }  "},{"title":"Add new plugin type and create it in Provider​","type":1,"pageTitle":"Add a new plugin","url":"/docs/contribute/connectivity-diagnosis/new-plugin#add-new-plugin-type-and-create-it-in-provider","content":"Plugin types are defined in pkg/skoop/context/cluster.go. You should add a new type here. const ( NetworkPluginFlannel = &quot;flannel&quot; NetworkPluginCalico = &quot;calico&quot; NetworkPluginTerway = &quot;terway&quot; // add your new plugin type here )  After this, you also need to create your plugin in supported cloud providers at pkg/skoop/provider/&lt;provider name&gt;.go. For example: func (g genericProvider) CreateNetwork(ctx *context.Context) (network.Network, error) { switch ctx.ClusterConfig().NetworkPlugin { case context.NetworkPluginFlannel: return generic.NewFlannelNetwork(ctx) case context.NetworkPluginCalico: return generic.NewCalicoNetwork(ctx) // add your plugin type default: return nil, fmt.Errorf(&quot;not support cni type %q&quot;, ctx.ClusterConfig().NetworkPlugin) } }  Now, you can make your plugin work by adding --network plugin &lt;your plugin name&gt; to the CLI command. "},{"title":"Add plugin auto detection​","type":1,"pageTitle":"Add a new plugin","url":"/docs/contribute/connectivity-diagnosis/new-plugin#add-plugin-auto-detection","content":"You can add plugin auto detection inDetectNetworkPlugin() in pkg/utils/k8s.go by listing the DaemonSet in the cluster. func DetectNetworkPlugin(k8sCli *kubernetes.Clientset) (networkMode string, err error) { dss, err := k8sCli.AppsV1().DaemonSets(&quot;&quot;).List(context.Background(), metav1.ListOptions{}) if err != nil { return &quot;&quot;, err } for _, ds := range dss.Items { switch ds.Name { case &quot;kube-flannel-ds&quot;: return &quot;flannel&quot;, nil case &quot;calico-node&quot;: return &quot;calico&quot;, nil case &quot;terway-eniip&quot;: return &quot;terway-eniip&quot;, nil } } return &quot;&quot;, nil }  "},{"title":"Add e2e tests​","type":1,"pageTitle":"Add a new plugin","url":"/docs/contribute/connectivity-diagnosis/new-plugin#add-e2e-tests","content":"Finally, you should add plugin specific tests in test/skoop/e2e/testcase/plugins.go, and add your plugin to test/skoop/e2e/testcase/testcases.go. "},{"title":"Visualization","type":0,"sectionRef":"#","url":"/docs/guide/monitoring/visualization","content":"","keywords":""},{"title":"Using Prometheus & Grafana for visualization of metrics​","type":1,"pageTitle":"Visualization","url":"/docs/guide/monitoring/visualization#using-prometheus--grafana-for-visualization-of-metrics","content":"KubeSkoop provides a standard Prometheus format metric output service. You can quickly integrate KubeSkoop's metrics into an existing monitoring system. Please refer to the configuration for details. tip If there is no ready-to-use monitoring service, please refer to the installation guide to set up a visual monitoring service. Refer to Prometheus Installation to complete the deployment and installation of Prometheus.Refer to Grafana Installation to complete the deployment and installation of Grafana. "},{"title":"Configuring KubeSkoop metrics​","type":1,"pageTitle":"Visualization","url":"/docs/guide/monitoring/visualization#configuring-kubeskoop-metrics","content":"KubeSkoop supports the service discovering of Prometheus running in Kubernetes. After installing Prometheus, you can view the ready instances by entering skoop-exporter in the search bar on the Status-&gt;Targets page, for example:  After the KubeSkoop instance is successfully scraped by Prometheus, you can complete the visualization of metrics through the following steps: Enter the Grafana console, click Configuration-&gt;Data sources-&gt;Add data source, select Prometheus, and add the address of the prepared Prometheus instance to the data source subscription of GrafanaCreate a new dashboard or select to create a new panel in an existing dashboard. In the panel configuration, select the data source configured in 1, enter inspector in the Metric browser, and you can see the associated KubeSkoop metrics. Select the desired information from it, for example, inspector_pod_netdevrxbytes. After inputting this, you can see the obtained data in the panel.In the visualization of metrics, you can set the legend and unit information of the metrics as needed. The legend supports configuring information such as the Pod's namespace, IP, and label. These supported legends can be configured in the panel's Legend. "},{"title":"Import the pre-defined default dashboard​","type":1,"pageTitle":"Visualization","url":"/docs/guide/monitoring/visualization#import-the-pre-defined-default-dashboard","content":"KubeSkoop provides a default Grafana dashboard configuration file that can follow version updates: curl https://raw.githubusercontent.com/alibaba/kubeskoop/main/deploy/resource/kubeskoop-exporter-dashboard.json -o dashboard.json  After logging in to the Grafana console, click Dashboards-&gt;Import-&gt;Upload JSON file, select the saved file for upload, select Take Prometheus as data source, and click Import to import it. You can then view the default dashboard. By selecting different panel groups, you can view monitoring metrics of different categories.  "},{"title":"Use Grafana & Loki to view visualized network events​","type":1,"pageTitle":"Visualization","url":"/docs/guide/monitoring/visualization#use-grafana--loki-to-view-visualized-network-events","content":""},{"title":"Installation​","type":1,"pageTitle":"Visualization","url":"/docs/guide/monitoring/visualization#installation","content":"Follow the official documentation to install Grafana Loki for different scenarios Grafana Loki Installation。 After installation, you can check the availability of Grafana Loki using the following methods: curl http://[Endpoint of Grafana Loki]:3100/ready  "},{"title":"Configure KubeSkoop event stream​","type":1,"pageTitle":"Visualization","url":"/docs/guide/monitoring/visualization#configure-kubeskoop-event-stream","content":"Grafana dashboard​ You can use Grafana to visualize the events which KubeSkoop pushed to Grafana Loki. Follow these steps to achieve visualization: After clicking Configuration-&gt;Data sources-&gt;Add data source, select Loki, and add the address of the Grafana Loki service to the data source subscription of Grafana. This can be an IP address or domain name with a default port of 3100.Create a new dashboard or select a new panel in an existing dashboard. In the panel configuration, select the data source configured in step 1 as the data source, and filter the required event information in the Label browser.In the event panel, you can query specific events through LogQL. After clicking on the event, you can view detailed on-site information. "},{"title":"Packet Capturing","type":0,"sectionRef":"#","url":"/docs/guide/packet-capturing","content":"","keywords":""},{"title":"Perform a packet capture​","type":1,"pageTitle":"Packet Capturing","url":"/docs/guide/packet-capturing#perform-a-packet-capture","content":"To start a packet capturing task, you need to provide the target, filter expression, and packet capturing duration, and click the Submit Task button. "},{"title":"Add Targets​","type":1,"pageTitle":"Packet Capturing","url":"/docs/guide/packet-capturing#add-targets","content":"By clicking the Add button of Targets, you can add packet capturing targets via the target selector.  In the Add Target window, you can add Node or Pod as the target. You can add single Pod/Node by its namespace &amp; name, or add multiple targets by label selector. When selecting Pod as target(s), by checking Also capture node packets, the Node where the Pod is running on will be added to the packet capturing target at the same time. "},{"title":"Filtering Packets​","type":1,"pageTitle":"Packet Capturing","url":"/docs/guide/packet-capturing#filtering-packets","content":"In Filter, you can add filter expressions to filter packet capturing results. Filter expressions are in the same form as tcpdump to use the Pcap filter syntax. For example, if you want to capture traffic to and from IP address 10.0.1.0, you can write the expression as: host 10.0.10.0  If there is no need to filter packets, you can leave the Filter field empty. "},{"title":"Download Task Result​","type":1,"pageTitle":"Packet Capturing","url":"/docs/guide/packet-capturing#download-task-result","content":"When task is completed, you can download the result to your local computer by clicking the Download button in the Result column of History. You can view the packet capturing file using network analysis tools such as Wireshark. "},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/quick-start","content":"Quick Start You can quickly deploy KubeSkoop, Prometheus, Grafana and Loki to your cluster via skoopbundle.yaml. kubectl apply -f https://raw.githubusercontent.com/alibaba/kubeskoop/main/deploy/skoopbundle.yaml tip skoopbundle.yaml starts with the minimum number of replicas and default configurations, which is not suitable for production environments. Please refer to installation to install a production-ready production-ready KubeSkoop instance. When installation is done, you can access the KubeSkoop Web Console by service webconsole. kubectl get svc -n kubeskoop webconsole You may need a Nodeport or LoadBalancer to acess from outside of the cluster. Default username is admin, and password is kubeskoop. Congratulations! You have successfully installed KubeSkoop. For more features of the console, see Web Console.","keywords":""},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":""},{"title":"Key Features​","type":1,"pageTitle":"Intro","url":"/docs/intro#key-features","content":""},{"title":"One-Shot Diagnose For Network Broken​","type":1,"pageTitle":"Intro","url":"/docs/intro#one-shot-diagnose-for-network-broken","content":"Diagnose in-cluster traffic between Pod,Service,Node and Ingress/Egress Traffic.Cover whole linux network stack: Socket,Bridge,Veth,Netfilter,sysctls…Support IaaS network probe for cloud providers. "},{"title":"In-Depth Kernel Monitor​","type":1,"pageTitle":"Intro","url":"/docs/intro#in-depth-kernel-monitor","content":"eBPF seamless kernel monitorCO-RE scripts on series kernel by BTFexport metrics to standard Prometheus metric API "},{"title":"Network Anomaly Event​","type":1,"pageTitle":"Intro","url":"/docs/intro#network-anomaly-event","content":"support dozens of anomy scenes recognitionexport anomy event to Grafana Loki or Web Console "},{"title":"User-friendly Web Console​","type":1,"pageTitle":"Intro","url":"/docs/intro#user-friendly-web-console","content":"Integrating all capabilities of KubeSkoop, provides network diagnosis, event monitoring, packet capturing, latency detection, etc. "},{"title":"Contributing​","type":1,"pageTitle":"Intro","url":"/docs/intro#contributing","content":"Feel free to open issues and pull requests. Any feedback is much appreciated! "},{"title":"Contact​","type":1,"pageTitle":"Intro","url":"/docs/intro#contact","content":"DingTalk Group ID(26720020148) "},{"title":"License​","type":1,"pageTitle":"Intro","url":"/docs/intro#license","content":"Most source code in KubeSkoop which running on userspace are licensed under the Apache License, Version 2.0. The BPF code in /bpf directory are licensed under the GPL v2.0 to compact with Linux kernel helper functions. "},{"title":"Specifying Cloud Provider","type":0,"sectionRef":"#","url":"/docs/reference/connectivity-diagnosis/cloud-providers","content":"Specifying Cloud Provider Cloud provider can be specified via --cloud-provider argument before execution of KubeSkoop diagnose. After setting cloud provider of the cluster, connectivity diagnosis will your configuration on the cloud, like VM security group, route tables, NAT, etc. Aliyun(Alibaba Cloud) Specify --cloud-provider aliyun to use Alibaba Cloud as the cloud provider. Except this, you should also use arguments below: Argument\tDescription--aliyun-access-key-id\taccess key for aliyun provider --aliyun-access-key-secret\taccess secret for aliyun provider --aliyun-security-token\tsecurity token for aliyun provider","keywords":""},{"title":"Running in Sidecar Mode","type":0,"sectionRef":"#","url":"/docs/guide/running-in-sidecar","content":"","keywords":""},{"title":"Example​","type":1,"pageTitle":"Running in Sidecar Mode","url":"/docs/guide/running-in-sidecar#example","content":"This example shows how to run an nginx deployment with KubeSkoop exporter sidecar. Save the yaml manifests below and apply to your Kubernetes cluster. apiVersion: apps/v1 kind: Deployment metadata: name: nginx-with-exporter spec: replicas: 1 selector: matchLabels: app: nginx-with-exporter template: metadata: labels: app: nginx-with-exporter spec: containers: - name: nginx image: nginx ports: - containerPort: 80 # add KubeSkoop sidecar container - name: exporter image: kubeskoop/kubeskoop:latest imagePullPolicy: Always command: - /bin/inspector - server # enable sidecar mode - --sidecar volumeMounts: - name: config-volume mountPath: /etc/config env: # set node name, pod name/namespace from env - name: INSPECTOR_NODENAME valueFrom: fieldRef: apiVersion: v1 fieldPath: spec.nodeName - name: INSPECTOR_PODNAME valueFrom: fieldRef: apiVersion: v1 fieldPath: metadata.name - name: INSPECTOR_PODNAMESPACE valueFrom: fieldRef: apiVersion: v1 fieldPath: metadata.namespace ports: - containerPort: 9012 volumes: - configMap: defaultMode: 420 name: kubeskoop-config name: config-volume --- apiVersion: v1 kind: ConfigMap metadata: name: kubeskoop-config data: config.yaml: |- debugmode: true port: 9102 metrics: probes: - name: netdev - name: io - name: sock - name: tcpsummary - name: tcp - name: tcpext - name: udp  This will create a Deployment nginx-with-exporter in your default namespace, along with ConfigMap kubeskoop-config. When pod started, you can get metrics from pod via kubectl. kubectl get --raw /api/v1/namespaces/default/pods/{{kubeskoop pod name}}:9102/proxy/metrics  The output should be like: # HELP inspector_pod_ioioreadbytes io ioioreadbytes count in netns/pod # TYPE inspector_pod_ioioreadbytes gauge inspector_pod_ioioreadbytes{namespace=&quot;default&quot;,node=&quot;node1&quot;,pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;,target_namespace=&quot;default&quot;,target_node=&quot;node1&quot;,target_pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;} 4096 # HELP inspector_pod_ioioreadsyscall io ioioreadsyscall count in netns/pod # TYPE inspector_pod_ioioreadsyscall gauge inspector_pod_ioioreadsyscall{namespace=&quot;default&quot;,node=&quot;node1&quot;,pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;,target_namespace=&quot;default&quot;,target_node=&quot;node1&quot;,target_pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;} 3765 # HELP inspector_pod_ioiowritebytes io ioiowritebytes count in netns/pod # TYPE inspector_pod_ioiowritebytes gauge inspector_pod_ioiowritebytes{namespace=&quot;default&quot;,node=&quot;node1&quot;,pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;,target_namespace=&quot;default&quot;,target_node=&quot;node1&quot;,target_pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;} 4096 # HELP inspector_pod_ioiowritesyscall io ioiowritesyscall count in netns/pod # TYPE inspector_pod_ioiowritesyscall gauge inspector_pod_ioiowritesyscall{namespace=&quot;default&quot;,node=&quot;node1&quot;,pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;,target_namespace=&quot;default&quot;,target_node=&quot;node1&quot;,target_pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;} 26578 # HELP inspector_pod_netdevrxbytes netdev netdevrxbytes count in netns/pod # TYPE inspector_pod_netdevrxbytes gauge inspector_pod_netdevrxbytes{namespace=&quot;default&quot;,node=&quot;node1&quot;,pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;,target_namespace=&quot;default&quot;,target_node=&quot;node1&quot;,target_pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;} 2139 # HELP inspector_pod_netdevrxdropped netdev netdevrxdropped count in netns/pod # TYPE inspector_pod_netdevrxdropped gauge inspector_pod_netdevrxdropped{namespace=&quot;default&quot;,node=&quot;node1&quot;,pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;,target_namespace=&quot;default&quot;,target_node=&quot;node1&quot;,target_pod=&quot;nginx-with-exporter-66fb94cbfc-4bxf5&quot;} 0 # ...and more  "},{"title":"Limitations​","type":1,"pageTitle":"Running in Sidecar Mode","url":"/docs/guide/running-in-sidecar#limitations","content":"For now, probes based on eBPF are not supported in sidecar mode. "},{"title":"Web Console","type":0,"sectionRef":"#","url":"/docs/guide/web-console","content":"","keywords":""},{"title":"Cluster Network Monitoring​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#cluster-network-monitoring","content":""},{"title":"Network Performance Dashboard​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#network-performance-dashboard","content":"Under Monitoring - Dashboard, you can access the dashboard of the cluster network, from which you can query the depth metric corresponding to the time point of the performance problem.  "},{"title":"Network Anomaly Events​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#network-anomaly-events","content":"Under Monitoring - Event, you can view the anomaly events in the cluster at the current time. You can also manually select time range, or filter based on event type, node, or the Pod namespace/name. By clicking Live in the upper right corner, you can monitor events within the cluster in real time based on the current filtering criteria.  "},{"title":"Network Graph​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#network-graph","content":"See Network Graph. "},{"title":"Diagnosis​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#diagnosis","content":""},{"title":"Connectivity Diagnosis​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#connectivity-diagnosis","content":"See Connectivity Diagnosis. "},{"title":"Packet Capturing​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#packet-capturing","content":"See Packet Capturing. "},{"title":"Latency Detection​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#latency-detection","content":"See Latency Detection. "},{"title":"Configuration​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#configuration","content":""},{"title":"Node Configuration​","type":1,"pageTitle":"Web Console","url":"/docs/guide/web-console#node-configuration","content":"Under Network - Configuration - Node Configuration, you can configure the KubeSkoop Agents in the cluster.  By clicking the Add or Delete, you can turn on or off the node's metrics/event probes, as well as configure the event collector from this page. tip After making changes to the node configuration, you need to click the Save Configuration button at the bottom right corner of the page to make the changes take effect. "},{"title":"Command line arguments","type":0,"sectionRef":"#","url":"/docs/reference/connectivity-diagnosis/command-line-arguments","content":"Command line arguments The following command line arguments are provided by kubeskoop cli. Argument\tDescription-p, --dport uint16\tDestination port for the network problem. -d, --dst string\tDestination address for the network problem. --protocol string\tProtocol for the network problem. (default tcp) -s, --src string\tSource address for the network problem. --cloud-provider string\tCloud provider of cluster. (default generic) --cluster-cidr string\tCluster pod CIDR. If not set, will try to detect it automatically. --kube-config string\tCluster kubeconfig file. (default ~/.kube/config) --network-plugin string\tNetwork plugin used in cluster. If not set, will try to auto detect it. --proxy-mode string\tProxy mode for kube-proxy. If not set, will try to detect it automatically. --format string\tOutput format of diagnose result, support d2/svg/json. If not set, only print simple path info on console. --http\tEnable an http server to show diagnose result. --http-address string\tListen address for http server. (default 127.0.0.1:8080) --output string\tOutput file name, default is output.d2/svg/json in current work directory. --aliyun-access-key-id string\tAliyun access key. --aliyun-access-key-secret string\tAliyun access secret. --aliyun-security-token string\tAliyun security token (optional). --collector-image string\tImage used for collector. (default kubeskoop/kubeskoop:&lt;version&gt;) --collector-namespace string\tNamespace where collector pods in. (default skoop) --collector-pod-wait-interval duration\tCollector pod running check interval. (default 2s) --collector-pod-wait-timeout duration\tCollector pod running check timeout. (default 2m0s) --calico-host-interface string\tHost interface for calico plugin. (default eth0) --calico-ipip-pod-mtu int\tPod MTU for calico plugin. Pod interface MTU in IPIP mode. (default 1480) --calico-pod-mtu int\tPod MTU for calico plugin. Pod interface MTU in BGP mode. (default 1500) --flannel-backend-type string\tBackend type for flannel plugin, support host-gw,vxlan,alloc. If not set, it will auto detect from flannel config. --flannel-bridge string\tBridge name for flannel plugin. (default cni0) --flannel-host-interface string\tHost interface for flannel plugin. (default eth0) --flannel-ip-masq\tShould do IP masquerade for flannel plugin. (default true) --flannel-pod-mtu int\tPod MTU for flannel plugin. If not set, it will auto detect from flannel cni mode (1450 for vxlan, 1500 for others).","keywords":""},{"title":"Supported Network Plugins","type":0,"sectionRef":"#","url":"/docs/reference/connectivity-diagnosis/network-plugins","content":"","keywords":""},{"title":"Flannel​","type":1,"pageTitle":"Supported Network Plugins","url":"/docs/reference/connectivity-diagnosis/network-plugins#flannel","content":"Type host-gw and vxlan are supported for Flannel cluster, and will auto detect which type should be used in diagnose. "},{"title":"Calico​","type":1,"pageTitle":"Supported Network Plugins","url":"/docs/reference/connectivity-diagnosis/network-plugins#calico","content":"BGP and IPIP mode are supported for Flannel cluster, and will auto detect which type should be used in diagnose. Note: Calico API Server should be installed in cluster to run connectivity diagnosis. For more information please see Calico documentation. "},{"title":"Roadmap","type":0,"sectionRef":"#","url":"/docs/roadmap","content":"Roadmap kubeskoop roadmap","keywords":""},{"title":"Probes, Metrics and Events","type":0,"sectionRef":"#","url":"/docs/reference/monitoring/probes-metrics-events","content":"","keywords":""},{"title":"Probes​","type":1,"pageTitle":"Probes, Metrics and Events","url":"/docs/reference/monitoring/probes-metrics-events#probes","content":"Probes supported by KubeSkoop are listed below. Probe Name\tDescription\tProbe Type\tData Source\tOverheadconntrack\tStatistics of conntrack\tMetrics\tnetlink\tLow qdisc\tStatistics of tc qdisc\tMetrics\tnetlink\tLow fd\tStatistics of file and socket descriptor\tMetrics\tprocfs\tMedium io\tStatistics of process IO\tMetrics\tprocfs\tLow ipvs\tStatistics of IPVS\tMetrics\tprocfs\tLow netdev\tStatistics of network device\tMetrics\tprocfs\tLow tcpext\tStatistics of the TCPExt\tMetrics\tprocfs\tLow tcp\tStatistics of TCP from snmp\tMetrics\tprofcs\tLow udp\tStatistics of UDP\tMetrics\tprofcs\tLow ip\tStatistics of IP\tMetrics\tprofcs\tLow sock\tStatistics of socket\tMetrics\tprocfs\tLow softnet\tStatistics of packet sent and dropped from network device\tMetrics\tprocfs\tLow tcpsummary\tStatistics of TCP queue and connection status\tMetrics\tprocfs\tMedium flow\tStatistics of connection flow\tMetrics\teBPF\tMedium netiftxlatency\tTrace network delay during transmission\tMetrics, Events\teBPF\tHigh biolatency\tTrace delay during block IO\tMetrics, Events\teBPF\tMedium kernellatency\tTrace latency in kernel\tMetrics, Events\teBPF\tHigh packetloss\tTrace packet loss\tMetrics, Events\teBPF\tMedium socketlatency\tTrace latency in socket\tMetrics, Events\teBPF\tHigh tcpreset\tTrace TCP reset\tEvents\teBPF\tLow virtcmdlatency\tTrace latency in virtio device\tMetrics, Events\teBPF\tHigh net_softirq\tTrace latency in software interrupt\tMetrics, Events\teBPF\tHigh tcpretrans\tTrace TCP packet retransmission\tMetrics, Events\teBPF\tLow "},{"title":"Metrics​","type":1,"pageTitle":"Probes, Metrics and Events","url":"/docs/reference/monitoring/probes-metrics-events#metrics","content":""},{"title":"Metric Labels​","type":1,"pageTitle":"Probes, Metrics and Events","url":"/docs/reference/monitoring/probes-metrics-events#metric-labels","content":"Theses labels are present on all metrics. Label Name\tDescriptiontarget_pod\tPod name or &quot;hostNetwork&quot; target_namespace\tPod namespace or &quot;hostNetwork&quot; target_node\tNode name "},{"title":"Metric List​","type":1,"pageTitle":"Probes, Metrics and Events","url":"/docs/reference/monitoring/probes-metrics-events#metric-list","content":"Metric Name\tProbe Name\tDescriptionkubeskoop_conntrack_found\tconntrack\tconntrack statistics &quot;found&quot; kubeskoop_conntrack_invalid\tconntrack\tconntrack statistics &quot;invalid&quot; kubeskoop_conntrack_ignore\tconntrack\tconntrack statistics &quot;ignore&quot; kubeskoop_conntrack_insert\tconntrack\tconntrack statistics &quot;insert&quot; kubeskoop_conntrack_insertfailed\tconntrack\tconntrack statistics &quot;insert_failed&quot; kubeskoop_conntrack_drop\tconntrack\tconntrack statistics &quot;drop&quot; kubeskoop_conntrack_earlydrop\tconntrack\tconntrack statistics &quot;early_drop&quot; kubeskoop_conntrack_error\tconntrack\tconntrack statistics &quot;error&quot; kubeskoop_conntrack_searchrestart\tconntrack\tconntrack statistics &quot;search_restart&quot; kubeskoop_conntrack_entries\tconntrack\tconntrack global statistics &quot;entries&quot; kubeskoop_conntrack_maxentries\tconntrack\tconntrack global statistics &quot;max_entries&quot; kubeskoop_qdisc_bytes\tqdisc\ttc qdisc statistics &quot;bytes&quot; kubeskoop_qdisc_packets\tqdisc\ttc qdisc statistics &quot;packets&quot; kubeskoop_qdisc_drops\tqdisc\ttc qdisc statistics &quot;drops&quot; kubeskoop_qdisc_qlen\tqdisc\ttc qdisc statistics &quot;qlen&quot; kubeskoop_qdisc_backlog\tqdisc\ttc qdisc statistics &quot;backlog&quot; kubeskoop_qdisc_overlimits\tqdisc\ttc qdisc statistics &quot;overlimits&quot; kubeskoop_fd_openfd\tfd\topened fd in pod kubeskoop_fd_opensocket\tfd\topened socket in pod kubeskoop_io_ioreadsyscall\tio\tio read syscalls count in pod kubeskoop_io_iowritesyscall\tio\tio write syscalls count in pod kubeskoop_io_ioreadbytes\tio\tio read bytes in pod kubeskoop_io_iowritebytes\tio\tio write bytes in pod kubeskoop_ipvs_connections\tipvs\tconnections of IPVS in pod kubeskoop_ipvs_incomingpackets\tipvs\tincoming packets of IPVS in pod kubeskoop_ipvs_outgoingbytes\tipvs\toutgoing bytes of IPVS in pod kubeskoop_ipvs_incomingbytes\tipvs\tincoming bytes of IPVS in pod kubeskoop_ipvs_outgoingpackets\tipvs\toutgoing packets of IPVS in pod kubeskoop_netdev_rxbytes\tnetdev\trx bytes of all network devices in pod kubeskoop_netdev_rxerrors\tnetdev\trx errors of all network devices in pod kubeskoop_netdev_txbytes\tnetdev\ttx bytes of all network devices in pod kubeskoop_netdev_txerrors\tnetdev\ttx error of all network devices in pod kubeskoop_netdev_rxpackets\tnetdev\trx packets of all network devices in pod kubeskoop_netdev_rxdropped\tnetdev\trx dropped packets of all network devices in pod kubeskoop_netdev_txpackets\tnetdev\ttx packets of all network devices in pod kubeskoop_netdev_txdropped\tnetdev\ttx dropped packets of all network devices in pod kubeskoop_tcpext_listendrops\ttcpext\tListenDrops of TCPExt kubeskoop_tcpext_listenoverflows\ttcpext\tListenOverflow of TCPExt kubeskoop_tcpext_tcpsynretrans\ttcpext\tTCPSynRetrans of TCPExt kubeskoop_tcpext_tcpfastretrans\ttcpext\tTCPFastRetrans of TCPExt kubeskoop_tcpext_tcpretransfail\ttcpext\tTCPRetransFail of TCPExt kubeskoop_tcpext_tcptimeouts\ttcpext\tTCPTimeouts of TCPExt kubeskoop_tcpext_tcpabortonclose\ttcpext\tTCPAbortOnClose of TCPExt kubeskoop_tcpext_tcpabortonmemory\ttcpext\tTCPAbortOnMemory of TCPExt kubeskoop_tcpext_tcpabortontimeout\ttcpext\tTCPAbortOnTimeout of TCPExt kubeskoop_tcpext_tcpabortonlinger\ttcpext\tTCPAbortOnLinger of TCPExt kubeskoop_tcpext_tcpabortondata\ttcpext\tTCPAbortOnData of TCPExt kubeskoop_tcpext_tcpabortfailed\ttcpext\tTCPAbortFailed of TCPExt kubeskoop_tcpext_tcpackskippedsynrecv\ttcpext\tTCPACKSkippedSynRecv of TCPExt kubeskoop_tcpext_tcpackskippedpaws\ttcpext\tTCPACKSkippedPAWS of TCPExt kubeskoop_tcpext_tcpackskippedseq\ttcpext\tTCPACKSkippedSeq of TCPExt kubeskoop_tcpext_tcpackskippedfinwait2\ttcpext\tTCPACKSkippedFinWait2 of TCPExt kubeskoop_tcpext_tcpackskippedtimewait\ttcpext\tTCPACKSkippedTimeWait of TCPExt kubeskoop_tcpext_tcpackskippedchallenge\ttcpext\tTCPACKSkippedChallenge of TCPExt kubeskoop_tcpext_tcprcvqdrop\ttcpext\tTCPRcvQDrop of TCPExt kubeskoop_tcpext_tcpmemorypressures\ttcpext\tTCPMemoryPressures of TCPExt kubeskoop_tcpext_tcpmemorypressureschrono\ttcpext\tTCPMemoryPressuresChrono of TCPExt kubeskoop_tcpext_pawsactive\ttcpext\tPAWSActive of TCPExt kubeskoop_tcpext_pawsestab\ttcpext\tPAWSEstab of TCPExt kubeskoop_tcpext_embryonicrsts\ttcpext\tEmbryonicRsts of TCPExt kubeskoop_tcpext_tcpwinprobe\ttcpext\tTCPWinProbe of TCPExt kubeskoop_tcpext_tcpkeepalive\ttcpext\tTCPKeepAlive of TCPExt kubeskoop_tcpext_tcpmtupfail\ttcpext\tTCPMTUPFail of TCPExt kubeskoop_tcpext_tcpmtupsuccess\ttcpext\tTCPMTUPSuccess of TCPExt kubeskoop_tcpext_tcpzerowindowdrop\ttcpext\tTCPZeroWindowDrop of TCPExt kubeskoop_tcpext_tcpbacklogdrop\ttcpext\tTCPBacklogDrop of TCPExt kubeskoop_tcpext_pfmemallocdrop\ttcpext\tPFMemallocDrop of TCPExt kubeskoop_tcpext_tcpwqueuetoobig\ttcpext\tTCPWqueueTooBig of TCPExt kubeskoop_tcp_activeopens\ttcp\tActiveOpens of TCP kubeskoop_tcp_passiveopens\ttcp\tPassiveOpens of TCP kubeskoop_tcp_retranssegs\ttcp\tRetransSegs of TCP kubeskoop_tcp_attemptfails\ttcp\tAttemptFails of TCP kubeskoop_tcp_estabresets\ttcp\tEstabResets of TCP kubeskoop_tcp_currestab\ttcp\tCurrEstab of TCP kubeskoop_tcp_insegs\ttcp\tInSegs of TCP kubeskoop_tcp_outsegs\ttcp\tOutSegs of TCP kubeskoop_tcp_inerrs\ttcp\tInErrs of TCP kubeskoop_tcp_outrsts\ttcp\tOutRsts of TCP kubeskoop_udp_indatagrams\tudp\tInDatagrams of UDP kubeskoop_udp_noports\tudp\tNoPorts of UDP kubeskoop_udp_inerrors\tudp\tInErrors of UDP kubeskoop_udp_outdatagrams\tudp\tOutDatagrams of UDP kubeskoop_udp_rcvbuferrors\tudp\tRcvbufErrors of UDP kubeskoop_udp_sndbuferrors\tudp\tSndbufErrors of UDP kubeskoop_udp_incsumerrors\tudp\tInCsumErrors of UDP kubeskoop_udp_ignoredmulti\tudp\tIgnoredMulti of UDP kubeskoop_ip_innoroutes\tip\tInNoRoutes of IP kubeskoop_ip_intruncatedpkts\tip\tInTruncatedPkts of IP kubeskoop_sock_inuse\tsock\tInuse of sock kubeskoop_sock_orphan\tsock\tOrphan of sock kubeskoop_sock_tw\tsock\tTW of sock kubeskoop_sock_alloc\tsock\tAlloc of sock kubeskoop_sock_mem\tsock\tMem of sock kubeskoop_softnet_processed\tsoftnet\tProcessed of softnet kubeskoop_softnet_dropped\tsoftnet\tDropped of softnet kubeskoop_tcpsummary_tcpestablishedconn\ttcpsummary\tESTABLISHED connection count kubeskoop_tcpsummary_tcptimewaitconn\ttcpsummary\tTIME_WAIT connection count kubeskoop_tcpsummary_tcptxqueue\ttcpsummary\ttx queue length of all TCP connections kubeskoop_tcpsummary_tcprxqueue\ttcpsummary\trx queue length of all TCP connections kubeskoop_netiftxlat_qdiscslow100ms\tnetiftxlatency\tqdisc latency exceeds 100ms during transmission kubeskoop_netiftxlat_netdevslow100ms\tnetiftxlatency\tnetdev transmit latency exceeds 100ms during transmission kubeskoop_kernellatency_rxslow\tkernellatency\tKernel packet receiving slow kubeskoop_kernellatency_rxslow100ms\tkernellatency\tKernel packet receiving latency exceeds 100ms kubeskoop_kernellatency_txslow\tkernellatency\tKernel packet transmitting slow kubeskoop_kernellatency_txslow100ms\tkernellatency\tKernel packet transmitting latency exceeds 100ms kubeskoop_packetloss_total\tpacketloss\tPacket dropped total count kubeskoop_packetloss_netfilter\tpacketloss\tPacket dropped in nf_hook_slow() kubeskoop_socketlatency_read100ms\tsocketlatency\tSocket read latency exceeds 100ms kubeskoop_socketlatency_read1ms\tsocketlatency\tSocket read latency exceeds 1ms kubeskoop_socketlatency_write100ms\tsocketlatency\tSocket write latency exceeds 100ms kubeskoop_socketlatency_write1ms\tsocketlatency\tSocket write latency exceeds 1ms kubeskoop_virtcmdlatency_latency100ms\tvirtcmdlatency\tVirtio send command latency exceeds 100ms kubeskoop_virtcmdlatency_latency\tvirtcmdlatency\tVirtio send command slow kubeskoop_softirq_schedslow\tnet_softirq\tSoftirq sched slow (from softirq_raise() to softirq_entry()) kubeskoop_softirq_schedslow100ms\tnet_softirq\tSoftirq sched latency exceeds 100ms kubeskoop_softirq_excuteslow\tnet_softirq\tSoftirq execute slow (from softirq_entry() to softirq_exit()) kubeskoop_softirq_excuteslow100ms\tnet_softirq\tSoftirq execute latency exceeds 100ms kubeskoop_flow_bytes\tflow\tBytes sent connection flow kubeskoop_flow_packets\tflow\tPackets sent of connection flow "},{"title":"Events​","type":1,"pageTitle":"Probes, Metrics and Events","url":"/docs/reference/monitoring/probes-metrics-events#events","content":""},{"title":"Event List​","type":1,"pageTitle":"Probes, Metrics and Events","url":"/docs/reference/monitoring/probes-metrics-events#event-list","content":"Event supported by KubeSkoop exporter are listed below. Event Name\tProbe Name\tDescription\tEvent BodyTXLAT_QDISC_100MS\tnetiftxlatency\tqdisc latency exceeds 100ms during transmission\t5-tuple(protocol, saddr, sport, daddr, dport), latency TXLAT_NETDEV_100MS\tnetiftxlatency\tnetdev transmit latency exceeds 100ms during transmission\t5-tuple(protocol, saddr, sport, daddr, dport), latency BIOLAT_10MS\tbiolatency\tBlock IO latency exceeds 10ms\tprocess name, pid, latency BIOLAT_100MS\tbiolatency\tBlock IO latency exceeds 100ms\tprocess name, pid, latency RXKERNEL_SLOW\tkernellatency\tKernel packet receiving latency exceeds 100ms\t5-tuple(protocol, saddr, sport, daddr, dport), latency in different locations TXKERNEL_SLOW\tkernellatency\tKernel packet transmitting latency exceeds 100ms\t5-tuple(protocol, saddr, sport, daddr, dport), latency in different locations PacketLoss\tpacketloss\tPacket dropped\t5-tuple(protocol, saddr, sport, daddr, dport), stacktrace SOCKETLAT_READSLOW\tsocketlatency\tSocket read slow\t5-tuple(protocol, saddr, sport, daddr, dport), latency SOCKETLAT_SENDSLOW\tsocketlatency\tSocket send slow\t5-tuple(protocol, saddr, sport, daddr, dport), latency TCPRESET_NOSOCK\ttcpreset\tTCP connection sent RST because of no socket\t5-tuple(protocol, saddr, sport, daddr, dport), socket state TCPRESET_ACTIVE\ttcpreset\tTCP connection sent active RST because of close() syscall or linger, etc.\t5-tuple(protocol, saddr, sport, daddr, dport), socket state TCPRESET_PROCESS\ttcpreset\tTCP connection sent RST because of no socket or exception in handshaking, etc.\t5-tuple(protocol, saddr, sport, daddr, dport), socket state TCPRESET_RECEIVE\ttcpreset\tTCP connection received RST\t5-tuple(protocol, saddr, sport, daddr, dport), socket state VIRTCMDEXCUTE\tvirtcmdlatency\tVirtio send command slow\tcpu, pid, latency NETSOFTIRQ_SCHED_SLOW\tnet_softirq\tSoftirq sched slow (from softirq_raise() to softirq_entry())\tcpu, pid, latency NETSOFTIRQ_SCHED_100MS\tnet_softirq\tSoftirq sched latency exceeds 100ms\tcpu, pid, latency NETSOFTIRQ_EXCUTE_SLOW\tnet_softirq\tSoftirq execute slow (from softirq_entry() to softirq_exit())\tcpu, pid, latency NETSOFTIRQ_EXCUTE_100MS\tnet_softirq\tSoftirq execute latency exceeds 100ms\tcpu, pid, latency TCPRetrans\ttcpretrans\tTCP retransmission\tstacktrace "}]